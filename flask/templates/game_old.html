<!DOCTYPE html>
<html>
  <head>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.23.0/dist/phaser.min.js"></script>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
    <script src="{{ url_for('static', filename='game_src/PriorityQueue.js') }}"></script>
    <script src="{{ url_for('static', filename='game_src/SpeechBubble.js') }}"></script>
    <script src="{{ url_for('static', filename='game_src/planning.js') }}"></script>
  </head>
  <body>

    <script>
      const tileSize = 64;
      const screenSizeX = 13;
      const screenSizeY = 11;

      const playerMsPerStep = 200;
      const robotMsPerStep = 350;

      // Local Development
      const baseURL = "http://0.0.0.0:8194/";
      // AWS EC2 Deployment
      // const baseURL = "http://ec2-52-14-97-33.us-east-2.compute.amazonaws.com:8194/";
      const logGameConfigEndpoint = "log_game_config";
      const logGameStateEndpoint = "log_game_state";

      const queryAskingDistance = 2; // tiles, in the l-infinity norm
      // const queryAnsweringDistance = 4; // tiles, in the l-infinity norm
      const moveTowardsHumanDistance = 6; // tiles, in the l-infinity norm
      const numTimesToTryAskingForHelp = 1;
      const cameraPadding = 1; // the robot must spawn more than these units away from the camera bounds

      const pointOfInterestString = " Chair ";
      const highlightPointString = " Computer ";
      const timeForDistractionTask = 10;

      const robotColor = 0x00ffff;
      const playerColor = 0xff0000;

      const scorePerTask = 10;

      const robotState = {
        OFFSCREEN: 0,
        APPROACH_HUMAN: 1,
        WALK_PAST_HUMAN: 2, // walks in the opposite direction of the human, and then transitions to offscreen
        STATIONARY: 3,
        LEAVE_SCREEN: 4, // walks off the screen
        GO_TOWARDS_GOAL: 5, // goes towards the goal until its offscreen
      }

      const playerState = {
        NAVIGATION_TASK: 0,
        DISTRACTION_TASK: 1,
        COMPLETED_TASKS: 2,
      }

      const load = {{load|default("false", false)}};
      dataToLoad = {{dataToLoad|default([], false)|tojson}};
      lastLoadedData = null;

      const config = {
        type: Phaser.AUTO, // Which renderer to use
        width: tileSize*screenSizeX, // Canvas width in pixels; must be odd multipliers so the player starts centered
        height: tileSize*screenSizeY, // Canvas height in pixels; must be odd multipliers so the player starts centered
        parent: "game-container", // ID of the DOM element to add the canvas to
        scene: {
          preload: preload,
          create: create,
          update: update,
          extend: {
            createDistractionTaskBar: createDistractionTaskBar,
            drawDistractionTaskBarProgress: drawDistractionTaskBarProgress,
            createRobotGoalRect: createRobotGoalRect,
            setHelpBubbleToAmIHere: setHelpBubbleToAmIHere,
            createTitleScreen: createTitleScreen,
            renderPlayerMovementAnimation: renderPlayerMovementAnimation,
          },
        },
        physics: {
          default: "arcade",
          arcade: {
            gravity: { y: 0 } // Top down game, so no gravity
          },
        },
      };

      const game = new Phaser.Game(config);

      function preload() {
        // Load the tiles and tile map (created in Tiled https://www.mapeditor.org/ )
        this.load.image("tiles", "./assets/tiles2.png");
        this.load.tilemapTiledJSON("map", "../assets/map2.json");
        this.load.image("minimap", "./assets/map2.png");

        // Load the character
        this.load.spritesheet(
          'characters',
          'assets/character_64x96_spritesheet_bw.png',
          {frameWidth: 64, frameHeight: 96},
        );

        // Load the robot
        this.load.spritesheet(
          'robot',
          'assets/robot.png',
          {frameWidth: 64, frameHeight: 64},
        );

        // Load the tasks for this game ID
        this.load.json('tasks', 'assets/tasks/{{gid}}.json');
      }

      function tileToGameXY(tile) {
        return {x : (tile.x + 0.5) * tileSize, y : (tile.y + 0.5) * tileSize};
      }

      function gameToTileXY(gameXY) {
        return {x : Math.floor(gameXY.x / tileSize), y : Math.floor(gameXY.y / tileSize)};
      }

      function create() {
        // Create the map and its layers
        game.map = this.make.tilemap({ key: "map" });
        game.tileset = game.map.addTilesetImage("tiles2", "tiles");
        game.belowLayer = game.map.createStaticLayer("Below Player", game.tileset, 0, 0);
        game.worldLayer = game.map.createStaticLayer("World", game.tileset, 0, 0);
        // game.worldLayer.setCollisionByProperty({ collides: true });
        // game.aboveLayer = game.map.createStaticLayer("Above Player", game.tileset, 0, 0);
        // game.aboveLayer.setDepth(10);
        // TODO (amal): preprocess this and save it in an assets json file
        game.roomLabels = {};
        game.xyToSemanticLabels = {};
        game.semanticLabelToRoomRectBounds = {};
        for (var i = 0; i < game.map.objects.length; i++) {
          if (game.map.objects[i].name == "Objects") {
            for (var j = 0; j < game.map.objects[i].objects.length; j++) {
              if (game.map.objects[i].objects[j].point) {
                var point = game.map.objects[i].objects[j];
                var wasLabel = false;

                if (game.map.objects[i].objects[j].properties && game.map.objects[i].objects[j].properties.length > 0) {
                  for (var k = 0; k < game.map.objects[i].objects[j].properties.length; k++) {
                    var property = game.map.objects[i].objects[j].properties[k];
                    if (property.name == "label" && property.value) {
                      game.roomLabels[point.name] = this.add.text(
                        Math.floor(point.x/tileSize)*tileSize + tileSize/2,
                        Math.floor(point.y/tileSize)*tileSize + tileSize/2,
                        point.name,
                        {
                          font: "32px monospace",
                          fill: "#ececec",
                          padding: { x: 0, y: 0 },
                          align: "center",
                        },
                    ).setOrigin(0.5, 0.5);
                    wasLabel = true;
                    break;
                    }
                  }
                }

                if (!wasLabel) {
                  var tileX = Math.floor(point.x/tileSize);
                  var tileY = Math.floor(point.y/tileSize);
                  var key = String([tileX, tileY]);
                  if (!(key in game.xyToSemanticLabels)) {
                    game.xyToSemanticLabels[String([tileX, tileY])] = new Set();
                  }
                  game.xyToSemanticLabels[String([tileX, tileY])].add(point.name);
                }
              } else { // If its not a point, it is a rectangle
                var rect = game.map.objects[i].objects[j];
                for (tileX = Math.ceil(rect.x/tileSize); tileX < Math.floor((rect.x+rect.width)/tileSize); tileX++) {
                  for (tileY = Math.ceil(rect.y/tileSize); tileY < Math.floor((rect.y+rect.height)/tileSize); tileY++) {
                    var key = String([tileX, tileY]);
                    if (!(key in game.xyToSemanticLabels)) {
                      game.xyToSemanticLabels[key] = new Set();
                    }
                    game.xyToSemanticLabels[key].add(rect.name);
                  }
                }
                game.semanticLabelToRoomRectBounds[rect.name] = {
                  x : rect.x,
                  y : rect.y,
                  width : rect.width,
                  height : rect.height,
                };
              }
            }
            break;
          }
        }
        game.semanticLabelsToXY = {};
        for (xyStr in game.xyToSemanticLabels) {
          var semanticLabels = game.xyToSemanticLabels[xyStr];
          var nums = xyStr.split(",");
          var x = parseFloat(nums[0]);
          var y = parseFloat(nums[1]);
          semanticLabels.forEach(function (semanticLabel) {
            if (!(semanticLabel in game.semanticLabelsToXY)) {
              game.semanticLabelsToXY[semanticLabel] = [];
            }
            game.semanticLabelsToXY[semanticLabel].push({x : x, y : y});
          });
        }
        console.log("semantic label maps", game.xyToSemanticLabels, game.semanticLabelsToXY);

        // Load the tasks for this Game ID
        game.tasks = this.cache.json.get('tasks');

        // Create the player
        game.player = this.physics.add.sprite(game.config.width/2, game.config.width/2, 'characters');
        game.player.setScale(0.80);
        game.player.setDepth(5);
        game.player.currentTile = {x : game.tasks.player_start_location.x, y : game.tasks.player_start_location.y};
        game.player.previousTile = game.player.currentTile;
        game.player.nextTile = game.player.currentTile;
        var gameXY = tileToGameXY(game.player.currentTile);
        game.player.x = gameXY.x;
        game.player.y = gameXY.y;
        game.player.taskPlan = null;
        game.player.taskI = 0;
        game.player.previousTaskI = game.player.taskI;
        game.player.score = 0;
        game.player.currentState = game.tasks.tasks.length > 0 ? playerState.NAVIGATION_TASK : playerState.COMPLETED_TASKS;
        game.player.enableBody();

        // Add collisions between the player and world layer
        // this.physics.add.collider(game.player, game.worldLayer);

        // Create the robot
        game.robot = this.physics.add.sprite(game.config.width/2, game.config.width/2, 'robot');
        game.robot.setDepth(5);
        game.robot.currentTile = {x : game.tasks.robot_offscreen_location.x, y : game.tasks.robot_offscreen_location.y};
        game.robot.previousTile = game.robot.currentTile;
        game.robot.goalTile = game.robot.currentTile;
        game.robot.plan = null;
        gameXY = tileToGameXY(game.robot.currentTile);
        game.robot.x = gameXY.x;
        game.robot.y = gameXY.y;
        game.robot.currentState = robotState.OFFSCREEN;
        // game.hasRobotStateChangedThisUpdate = false;
        setRobotState(robotState.OFFSCREEN); // repeated to properly set previousState
        game.robot.isBeingLed = false;
        game.robot.taskPlan = [];
        game.robot.currentActionI = 0;
        game.robot.actionInProgress = false;

        // Add the robot's help bubble
        game.questions = [
          "Can you tell me if I'm at the Lounge?",
          "Can you lead me towards Room 23?",
          "Am I in front of Room 11?",
          "I need help",
          "Is the room in front of me called the Lounge?",
        ];
        game.questionI = 0;
        game.robot.helpBubble = new SpeechBubble(this, 225, 300, 300, game.questions[game.questionI], [
          {
            text : "Yes",
            rowI: 0,
            callbackFunction : () => console.log("Yes button clicked"),
          },
          {
            text : "No",
            rowI: 1,
            callbackFunction : () => console.log("No button clicked"),
          },
        ]);
        game.robot.helpBubble.setVisible(false);

        // Create and configure the camera
        game.camera = this.cameras.main;
        game.camera.startFollow(game.player);
        game.camera.setBounds(0, 0, game.map.widthInPixels, game.map.heightInPixels);

        // Add the compass
        game.compass = {};
        game.compass.radius = 64*1.0
        game.compass.circle = this.add.graphics({ x: 0, y: 0 });
        game.compass.circle.fillStyle(0x000000, 0.5);
        game.compass.circle.lineStyle(4, 0xececec, 0.5);
        game.compass.circle.fillCircle(0, 0, game.compass.radius);
        game.compass.circle.setDepth(3);

        game.compass.playerArrow = this.add.graphics({ x: 0, y: 0 });
        game.compass.playerArrow.lineStyle(4, playerColor, 0.5);
        game.compass.playerArrow.lineBetween(0, 0, game.compass.radius, 0);
        game.compass.playerArrow.setDepth(4);
        game.compass.playerGoalText = this.add.text(game.compass.radius, 0, "", {
          font: "16px monospace",
          fill: "#ff0000",
          padding: { x: 0, y: 0 },
          align: "center",
        });
        game.compass.playerGoalText.setDepth(4);

        game.compass.robotArrow = this.add.graphics({ x: 0, y: 0 });
        game.compass.robotArrow.lineStyle(4, robotColor, 0.5);
        game.compass.robotArrow.lineBetween(0, 0, game.compass.radius, 0);
        game.compass.robotArrow.setDepth(4);
        game.compass.robotGoalText = this.add.text(game.compass.radius, 0, "", {
          font: "16px monospace",
          fill: "#00ffff",
          padding: { x: 0, y: 0 },
          align: "center",
        });
        game.compass.robotGoalText.setDepth(4);

        // Configure the keyboard input
        game.cursors = this.input.keyboard.createCursorKeys();

        // Configure the mouse click event -- often used for easy debugging
        this.input.on('pointerdown', function (pointer) {
          // // Set the robot goal
          // game.robot.goalTile = gameToTileXY({x : game.camera.scrollX + pointer.x, y : game.camera.scrollY + pointer.y});
          // game.robot.plan = generatePlan(game.robot.currentTile, [game.robot.goalTile], game.robot.goalTile, isValidTile);

          // // Move the speech bubble position
          // game.robot.helpBubble.setPosition(pointer.x, pointer.y);

          // // Change the speech bubble text
          // game.questionI = (game.questionI + 1) % game.questions.length;
          // game.robot.helpBubble.setText(game.questions[game.questionI]);

          // // Change the speech bubble visibility
          // game.robot.helpBubble.setVisible(!game.robot.helpBubble.getVisibile());

          // // Change the speech bubble width
          // game.questionI = (game.questionI + 1) % game.questions.length;
          // game.robot.helpBubble.setWidth(((game.questionI % 2) + 1)*200);

          // // Change the speech bubble questions
          // game.questionI++;
          // if (game.questionI % 3 == 0) {
          //   game.robot.helpBubble.setText("Excuse me. Am I at " + game.tasks.robotActions[game.robot.currentActionI].robotAction.targetStr + "?");
          //   game.robot.helpBubble.setButtons([
          //     {
          //       text : "Yes",
          //       callbackFunction : () => console.log("Yes button clicked"),
          //     },
          //     {
          //       text : "No",
          //       callbackFunction : () => console.log("No button clicked"),
          //     },
          //   ]);
          // } else if (game.questionI % 3 == 1) {
          //   game.robot.helpBubble.setText("Excuse me. Can you lead me towards " + game.tasks.robotActions[game.robot.currentActionI].robotAction.targetStr + "?");
          //   game.robot.helpBubble.setButtons([
          //     {
          //       text : "Yes",
          //       callbackFunction : () => console.log("Yes button clicked"),
          //     },
          //     {
          //       text : "No",
          //       callbackFunction : () => console.log("No button clicked"),
          //     },
          //   ]);
          // } else {
          //   game.robot.helpBubble.setText("Thank you for leading me towards " + game.tasks.robotActions[game.robot.currentActionI].robotAction.targetStr + ". Let me know when I should stop following you.");
          //   game.robot.helpBubble.setButtons([
          //     {
          //       text : "Stop Following",
          //       callbackFunction : () => console.log("Stop Following button clicked"),
          //     },
          //   ]);
          // }

          // // Cycle through robot states
          // game.robot.currentState = (game.robot.currentState + 1) % 3;
          // console.log("game.robot.currentState", game.robot.currentState);
          // if (game.robot.currentState == robotState.APPROACH_HUMAN) {
          //   var robotSpawnTile = getOffScreenTileInDirectionOfHumanMotion(false);
          //   if (robotSpawnTile != null) {
          //     // Spawn the robot there
          //     game.robot.currentTile = robotSpawnTile;
          //   } else {
          //     console.log("Failed to compute a spawn point for the robot");
          //   }
          // }
        });

        // Create the distraction task bar
        this.createDistractionTaskBar();
        setDistractionTaskBarVisible(false);

        // Create help text in the top-left corner
        game.baseInstructionsStr = "Arrow keys to move";
        game.instructionText = this.add.text(16, 16, "", {
          font: "24px monospace",
          fill: "#ececec",
          padding: { x: 20, y: 10 },
          backgroundColor: "#000000"
        });
        game.instructionText.setOrigin(0.0, 0.0); // top-left
        game.instructionText.setScrollFactor(0);
        game.instructionText.setDepth(6);
        // regenerateInstructionText();

        // Create score text in the top-right corner
        game.scoreText = this.add.text(game.config.width-16, 16, "", {
          font: "24px monospace",
          fill: "#ececec",
          padding: { x: 20, y: 10 },
          backgroundColor: "#000000"
        });
        game.scoreText.setOrigin(1.0, 0.0); // top-right
        game.scoreText.setScrollFactor(0);
        game.scoreText.setDepth(6);
        // regenerateScoreText();

        // Create the map in the bottom-right corner
        game.minimap = this.physics.add.sprite(game.config.width/2, game.config.width/2, 'minimap');
        game.minimap.setScale(0.075);
        game.minimap.setOrigin(0.0, 0.0); // bottom-right
        game.minimap.setDepth(15);
        game.minimap.setAlpha(0.85);
        var minimapOffset = game.config.width/100;
        // game.minimap.cameraOffset.setTo(200, 500)
        game.minimap.setPosition(minimapOffset + game.camera.scrollX, game.config.height-minimapOffset-game.minimap.displayHeight+game.camera.scrollY);
        // game.minimap.fixedToCamera = true;
        game.minimap.setScrollFactor(0.0, 0.0);
        game.minimap.enableBody();

        game.minimap.cameraBox = this.add.graphics({ x: 0, y: 0 });
        game.minimap.cameraBox.fillStyle(0x898989, 0.5);
        game.minimap.cameraBox.lineStyle(2, 0x000000, 0.5);
        game.minimap.cameraBox.setScrollFactor(0.0, 0.0);
        game.minimap.cameraBox.setDepth(15);
        game.minimap.cameraBox.fillRect(0, 0, game.config.width*game.minimap.scale, game.config.height*game.minimap.scale);
        game.minimap.cameraBox.strokeRect(0, 0, game.config.width*game.minimap.scale, game.config.height*game.minimap.scale);

        game.minimap.playerDot = this.add.graphics({ x: 0, y: 0 });
        game.minimap.playerDot.fillStyle(playerColor, 0.85);
        game.minimap.playerDot.fillCircle(0, 0, 3);
        game.minimap.playerDot.setDepth(15);
        game.minimap.playerDot.setScrollFactor(0.0, 0.0);

        game.minimap.playerGoal = this.add.graphics({ x: 0, y: 0 });
        game.minimap.playerGoal.lineStyle(2, playerColor, 0.85);
        var points = [];
        for (var i = 0; i < 5; i++) {
          points.push(new Phaser.Geom.Point(8*Math.cos(-Math.PI/2+Math.PI*2*((2*i)%5)/5), 8*Math.sin(-Math.PI/2+Math.PI*2*((2*i)%5)/5)));
        }
        game.minimap.playerGoal.strokePoints(points, true);
        game.minimap.playerGoal.setDepth(15);
        game.minimap.playerGoal.setScrollFactor(0.0, 0.0);
        game.minimap.playerGoal.setVisible(true);

        game.minimap.robotDot = this.add.graphics({ x: 0, y: 0 });
        game.minimap.robotDot.fillStyle(robotColor, 0.85);
        game.minimap.robotDot.fillCircle(0, 0, 3);
        game.minimap.robotDot.setDepth(15);
        game.minimap.robotDot.setScrollFactor(0.0, 0.0);

        // Configure the highglighting box over the target computer
        game.highlightBox = this.add.graphics({ x: 0, y: 0 });
        game.highlightBox.lineStyle(4, playerColor, 0.5);
        game.highlightBox.strokeRect(0, 0, tileSize, tileSize);
        updateHighlightBox();

        // Create the title screen
        this.createTitleScreen();

        // Add red outline for when we run out of time
        game.negativeScoreRedOutline = this.add.graphics({ x: 0, y: 0 });
        game.negativeScoreRedOutline.lineStyle(tileSize, 0xff0000, 0.75);
        game.negativeScoreRedOutline.strokeRect(0, 0, game.config.width, game.config.height);
        game.negativeScoreRedOutline.setScrollFactor(0.0, 0.0);
        game.negativeScoreRedOutline.setVisible(false);

        // Create the player animations
        this.anims.create({
            key: 'down',
            frames: this.anims.generateFrameNumbers('characters', {start: 0, end: 3}),
            frameRate: 10,
            repeat: -1
        });
        this.anims.create({
            key: 'up',
            frames: this.anims.generateFrameNumbers('characters', {start: 4, end: 7}),
            frameRate: 10,
            repeat: -1
        });
        this.anims.create({
            key: 'left',
            frames: this.anims.generateFrameNumbers('characters', {start: 8, end: 11}),
            frameRate: 10,
            repeat: -1
        });
        this.anims.create({
            key: 'right',
            frames: this.anims.generateFrameNumbers('characters', {start: 12, end: 15}),
            frameRate: 10,
            repeat: -1
        });
        game.player.anims.play('left', true);

        // Render the player's bounding box
        // this.physics.world.createDebugGraphic();

        game.start_time = Date.now(); // ms

        getCurrentTaskPlan();
        game.player.currentTaskDistance = game.player.taskPlan.length;

        // Log the game configuration and initial state
        if (!load) {
          logData(logGameConfigEndpoint, getGameConfig());
          logData(logGameStateEndpoint, getGameState());
          game.isRunning = false;
        }

      }

      function post_form(path, params, method='post') {

        // The rest of this code assumes you are not using a library.
        // It can be made less wordy if you use one.
        const form = document.createElement('form');
        form.method = method;
        form.action = path;

        for (const key in params) {
          if (params.hasOwnProperty(key)) {
            const hiddenField = document.createElement('input');
            hiddenField.type = 'hidden';
            hiddenField.name = key;
            hiddenField.value = params[key];

            form.appendChild(hiddenField);
          }
        }

        document.body.appendChild(form);
        form.submit();
      }

      function createTitleScreen() {
        var offset = game.config.width/20;
        game.titleScreen = this.add.graphics({ x: game.config.width/2, y: game.config.height/2 });
        game.titleScreen.fillStyle(0xececec, 1.0);
        game.titleScreen.lineStyle(4, 0x000000, 1.0);
        game.titleScreen.fillRect(-game.config.width/2, -game.config.height/2, game.config.width, game.config.height); // White background
        // game.titleScreen.strokeRoundedRect(-w/2, -h/2, w, h, 16);
        // game.titleScreen.fillRoundedRect(-w/2, -h/2, w, h, 16);
        game.titleScreen.setDepth(16);

        game.titleScreen.title = this.add.text(
          game.config.width/2,
          offset,
          "Virus Attack!",
          {
            font: "32px monospace",
            fill: "rgba(0, 0, 0, 1.0)",
          },
        ).setOrigin(0.5, 1.0);
        game.titleScreen.title.setDepth(16);

        game.titleScreen.description = this.add.text(
          game.config.width/2,
          game.config.height/2,
          "A virus infected your office's computers last night! You are an IT admin and must contain the virus before employees arrive. \n\nAs you do so, you may see the company's mail delivery robot. This robot is new, so it is still learning about the building. \n\nInstructions:\n\t1) Use the arrow keys to move. \n\t2) Hold down Space to clean a computer. \n\t3) If the robot talks to you, you can ignore it or click the buttons to respond to it. \n\t4) The instructions in the top-left tell you where to go and when to go there. \n\t5) Every cleaned computer is 10 points, and every second late you arrive is -1 point. \n\t6) The map in the bottom-left shows you important locations.",
          {
            font: "24px monospace",
            fill: "rgba(0, 0, 0, 1.0)",
            wordWrap: {width: game.config.width-2*offset},
          },
        ).setOrigin(0.5, 0.5);
        game.titleScreen.description.setDepth(16);

        game.titleScreen.title.y = game.titleScreen.description.y - game.titleScreen.description.height/2 - game.titleScreen.title.height;

        game.titleScreen.startButton = this.add.text(
          game.config.width/2,
          game.titleScreen.description.y + game.titleScreen.description.height/2 + game.titleScreen.title.height,
          "Start",
          {
            font: "32px monospace",
            fill: "rgba(0, 0, 0, 1.0)",
            backgroundColor: "rgba(255, 0, 0, 1.0)"
          },
        ).setOrigin(0.5, 0.0);
        game.titleScreen.startButton.setInteractive();
        var scene = this;
        game.titleScreen.startButton.on('pointerdown', function() {
          game.titleScreen.startButton.destroy();
          game.titleScreen.description.destroy();
          game.titleScreen.title.destroy();
          game.titleScreen.destroy();
          initializeGamePlayerTimer(scene);
          game.isRunning = true;
        });
        game.titleScreen.startButton.setDepth(16);
      }

      function createEndingScreen(scene) {
        var offset = game.config.width/20;
        game.endingScreen = scene.add.graphics({ x: game.config.width/2, y: game.config.height/2 });
        game.endingScreen.fillStyle(0xececec, 1.0);
        game.endingScreen.lineStyle(4, 0x000000, 1.0);
        game.endingScreen.fillRect(-game.config.width/2, -game.config.height/2, game.config.width, game.config.height); // White background
        // game.endingScreen.strokeRoundedRect(-w/2, -h/2, w, h, 16);
        // game.endingScreen.fillRoundedRect(-w/2, -h/2, w, h, 16);
        game.endingScreen.setDepth(16);

        game.endingScreen.title = scene.add.text(
          game.config.width/2,
          offset,
          "Completed Tasks",
          {
            font: "32px monospace",
            fill: "rgba(0, 0, 0, 1.0)",
          },
        ).setOrigin(0.5, 1.0);
        game.endingScreen.title.setDepth(16);

        game.endingScreen.description = scene.add.text(
          game.config.width/2,
          game.config.height/2,
          "You have succesfully cleared all viruses. \n\nScore: "+game.player.score.toString()+" / "+(game.tasks.tasks.length*scorePerTask).toString(),
          {
            font: "24px monospace",
            fill: "rgba(0, 0, 0, 1.0)",
            wordWrap: {width: game.config.width-2*offset},
          },
        ).setOrigin(0.5, 0.5);
        game.endingScreen.description.setDepth(16);

        game.endingScreen.title.y = game.endingScreen.description.y - game.endingScreen.description.height/2 - game.endingScreen.title.height;

        game.endingScreen.continueButton = scene.add.text(
          game.config.width/2,
          game.endingScreen.description.y + game.endingScreen.description.height/2 + game.endingScreen.title.height,
          "Continue",
          {
            font: "32px monospace",
            fill: "rgba(0, 0, 0, 1.0)",
            backgroundColor: "rgba(255, 0, 0, 1.0)"
          },
        ).setOrigin(0.5, 0.0);
        game.endingScreen.continueButton.setInteractive();
        var scene = this;
        game.endingScreen.continueButton.on('pointerdown', function() {
          // game.endingScreen.continueButton.destroy();
          // game.endingScreen.description.destroy();
          // game.endingScreen.title.destroy();
          // game.endingScreen.destroy();
          post_form('/post_survey', {uuid: "{{ uuid }}"});
        });
        game.endingScreen.continueButton.setDepth(16);

        game.endingScreen.setScrollFactor(0.0, 0.0);
        game.endingScreen.title.setScrollFactor(0.0, 0.0);
        game.endingScreen.description.setScrollFactor(0.0, 0.0);
        game.endingScreen.continueButton.setScrollFactor(0.0, 0.0);

        console.log("Created ending screen");
      }

      function setHelpBubbleVisible(visible) {
        // console.log("setHelpBubbleVisible", visible);
        game.robot.helpBubble.setVisible(visible);
        if (game.minimap.robotGoal) {
          game.minimap.robotGoal.setVisible(visible);
        }
      }

      function regenerateInstructionText() {
        game.instructionText.text = "";//game.baseInstructionsStr;
        if (game.player.currentState == playerState.NAVIGATION_TASK) {
          game.instructionText.text += "Goal: "+game.tasks.tasks[game.player.taskI].semanticLabel;
          var remainingSecs = Math.round((game.player.timer.delay - game.player.timer.getProgress()*game.player.timer.delay)/1000);
          game.instructionText.text += "\nTime: "+remainingSecs.toString()+" secs";
        } else if (game.player.currentState == playerState.DISTRACTION_TASK) {
          game.instructionText.text += "Hold Space at the red computer.";
        } else if (game.player.currentState == playerState.COMPLETED_TASKS) {
          game.instructionText.text += "Completed tasks!";
        }
      }

      function regenerateScoreText() {
        game.scoreText.text = "Score: " + game.player.score.toString();
      }

      function hasCompletedCurrentNavigationTask() {
        if (game.player.taskI >= game.tasks.tasks.length) {
          return false;
        }

        var currentLocationKey = String([game.player.currentTile.x, game.player.currentTile.y]);
        if (currentLocationKey in game.xyToSemanticLabels) {
          var currentSemanticLabels = game.xyToSemanticLabels[currentLocationKey];
          var goalSemanticLabel = game.tasks.tasks[game.player.taskI].semanticLabel;
          return currentSemanticLabels.has(goalSemanticLabel);
        }

        // return game.player.taskPlan != null && game.player.taskPlan.length <= 1;

        // var currentLocationKey = String([game.player.currentTile.x, game.player.currentTile.y]);
        // if (currentLocationKey in game.xyToSemanticLabels) {
        //   var currentSemanticLabels = game.xyToSemanticLabels[currentLocationKey];
        //   var goalSemanticLabel = game.tasks.tasks[game.player.taskI].semanticLabel+pointOfInterestString;
        //   var retval = false;
        //   currentSemanticLabels.forEach(function(currentSemanticLabel) {
        //     retval = retval || (currentSemanticLabel == goalSemanticLabel);
        //   });
        //   return retval;
        // }

        return false;
      }

      function createDistractionTaskBar() {
        var w = game.config.width*4/5;
        var h = game.config.height/7;
        var x = -w/2;
        var y = -h/2;
        game.distractionTaskBar = this.add.graphics({ x: game.config.width/2, y: game.config.height/2 });
        game.distractionTaskBar.width = w;
        game.distractionTaskBar.height = h;
        game.distractionTaskBar.fillStyle(0xececec, 0.9);
        game.distractionTaskBar.lineStyle(4, 0x000000, 0.9);
        game.distractionTaskBar.strokeRoundedRect(x, y, w, h, 16);
        game.distractionTaskBar.fillRoundedRect(x, y, w, h, 16);
        game.distractionTaskBar.setDepth(6);
        game.distractionTaskText = this.add.text(game.distractionTaskBar.x, w/40, "Clearing viruses. Continue holding the Space bar...", {
          font: "18px monospace",
          fill: "rgba(0, 0, 0, 0.9)",
        }).setOrigin(0.5, 0.5);
        game.distractionTaskText.setDepth(6);
      }

      function setDistractionTaskBarVisible(visible) {
        game.distractionTaskBar.setVisible(visible);
        game.distractionTaskText.setVisible(visible);
        if (visible) {
          game.distractionTaskBar.x = game.config.width/2+game.camera.scrollX;
          game.distractionTaskBar.y = game.config.height/2+game.camera.scrollY;
          game.distractionTaskText.x = game.config.width/2+game.camera.scrollX;
          game.distractionTaskText.y = game.distractionTaskBar.y-game.distractionTaskBar.height/2 + game.distractionTaskBar.width/40 +game.distractionTaskText.height/2;
        } else if (game.distractionTaskBar.progressBar != null) {
          game.distractionTaskBar.progressBar.destroy();
          game.distractionTaskBar.progressBar = null;
        }
      }

      function drawDistractionTaskBarProgress() {
        if (game.distractionTaskBar.progressBar != null) {
          game.distractionTaskBar.progressBar.destroy();
        }
        var w = game.distractionTaskBar.width*38/40;
        var h = game.distractionTaskBar.height/3;
        var x = game.distractionTaskText.x-w/2;
        var y = ((game.distractionTaskText.y + game.distractionTaskText.height/2)*2/3 + (game.distractionTaskBar.y + game.distractionTaskBar.height/2)*1/3);
        game.distractionTaskBar.progressBar = this.add.graphics({ x: x, y: y });
        game.distractionTaskBar.progressBar.fillStyle(0x898989, 0.9);
        // game.distractionTaskBar.progressBar.fillRoundedRect(0, 0, w*game.distractionTaskTimer.getOverallProgress(), h, 4);
        game.distractionTaskBar.progressBar.fillRoundedRect(0, 0, w*game.distractionTaskTimerSecs/timeForDistractionTask, h, 4);
        game.distractionTaskBar.progressBar.setDepth(6);
      }

      function hasCompletedCurrentDistractionTask() {
        return game.player.hasCompletedDistractionTask;
      }

      function getGameConfig() {
        return {
          uuid:"{{uuid}}",
          gid:"{{gid}}",
          start_time: game.start_time,
          playerMsPerStep: playerMsPerStep,
          robotMsPerStep: robotMsPerStep,
        };
      }

      function getGameState() {
        return {
          // User study details
          uuid:"{{uuid}}",
          gid:"{{gid}}",
          // Game state
          dtime: Date.now() - game.start_time,
          player: {
            currentTile: game.player.currentTile,
            nextTile: game.player.nextTile,
          },
          robot: {
            currentTile: game.robot.currentTile,
            plan: game.robot.plan,
          },
          // Animation information
          player_anim_is_playing: game.player.anims.isPlaying,
          player_anim_key: game.player.anims.getCurrentKey(),
          robot_anim_key: null,
          active_player_movement_timer: game.player.movementTimer != null,
          active_robot_movement_timer: game.robot.movementTimer != null,
        };
      }

      function logData(endpoint, data) {
        var url = baseURL + endpoint;
        // console.log("Send ", data)
        $.ajax({
          type : "POST",
          url : url,
          data: JSON.stringify(data, null, '\t'),
          contentType: 'application/json;charset=UTF-8',
          success: function(received_data, status) {
              // console.log(`${received_data} and status is ${status}`);
          }
        });
      }

      // Return whether or not a tile is valid for the player/robot to be in.
      // includePlayer indicates whether we should treat the player as an obstacle,
      // and includeRobot indicates whether we should treat the robot as an
      // obstacle
      function isValidTile(tile, includePlayer, includeRobot) {
        return (
          tile.x >= 0 &&
          tile.x < game.map.width &&
          tile.y >= 0 &&
          tile.y < game.map.height &&
          (!includePlayer || !((tile.x == game.player.currentTile.x && tile.y == game.player.currentTile.y) || (tile.x == game.player.nextTile.x && tile.y == game.player.nextTile.y))) &&
          (!includeRobot || game.robot.currentTile == null || !((tile.x == game.robot.currentTile.x && tile.y == game.robot.currentTile.y) || (game.robot.plan != null && game.robot.plan.length > 0 && tile.x == game.robot.plan[0].x && tile.y == game.robot.plan[0].y))) &&
          game.worldLayer.getTileAt(tile.x, tile.y) == null
        )
      }

      function rotationToOrigin(rotation) {
        if ((rotation >= -Math.PI/4 && rotation <= 0) || (rotation <= Math.PI/4 && rotation >= 0)) {
          originX = 0;
          originY = (rotation + Math.PI/4)/(Math.PI/2);
        } else if (rotation <= -Math.PI/4 && rotation >= -3*Math.PI/4) {
          originX = (-rotation - Math.PI/4)/(Math.PI/2);
          originY = 1;
        } else if (rotation <= -3*Math.PI/4 || rotation >= 3*Math.PI/4) {
          originX = 1;
          if (rotation < 0) {
            originY = (-rotation-3*Math.PI/4)/(Math.PI/2);
          } else {
            originY = (rotation-3*Math.PI/4)/(Math.PI/2);
          }
        } else if (rotation >= Math.PI/4 && rotation <= 3*Math.PI/4) {
          originX = (rotation - Math.PI/4)/(Math.PI/2);
          originY = 0;
        } else {
          throw "rotation that did not fit in range "+rotation.toString();
        }
        return {x: originX, y: originY};
      }

      function objectsOverlaps(obj0, obj1) {
        var w0 = obj0.width*obj0.scale;
        var h0 = obj0.height*obj0.scale;
        var x0 = obj0.x-obj0.originX*w0+(1-obj0.scrollFactorX)*game.camera.scrollX;
        var y0 = obj0.y-obj0.originY*h0+(1-obj0.scrollFactorY)*game.camera.scrollY;
        var w1 = obj1.width*obj1.scale;
        var h1 = obj1.height*obj1.scale;
        var x1 = obj1.x-obj1.originX*w1+(1-obj1.scrollFactorX)*game.camera.scrollX;
        var y1 = obj1.y-obj1.originY*h1+(1-obj1.scrollFactorY)*game.camera.scrollY;

        var topLeft0 = (
          x1 <= x0 && x0 <= x1 + w1 &&
          y1 <= y0 && y0 <= y1 + h1
        );
        var topRight0 = (
          x1 <= x0 + w0 && x0 + w0 <= x1 + w1 &&
          y1 <= y0 && y0 <= y1 + h1
        );
        var bottomLeft0 = (
          x1 <= x0 && x0 <= x1 + w1 &&
          y1 <= y0 + h0 && y0 + h0 <= y1 + h1
        );
        var bottomRight0 = (
          x1 <= x0 + w0 && x0 + w0 <= x1 + w1 &&
          y1 <= y0 + h0 && y0 + h0 <= y1 + h1
        );

        var topLeft1 = (
          x0 <= x1 && x1 <= x0 + w0 &&
          y0 <= y1 && y1 <= y0 + h0
        );
        var topRight1 = (
          x0 <= x1 + w1 && x1 + w1 <= x0 + w0 &&
          y0 <= y1 && y1 <= y0 + h0
        );
        var bottomLeft1 = (
          x0 <= x1 && x1 <= x0 + w0 &&
          y0 <= y1 + h1 && y1 + h1 <= y0 + h0
        );
        var bottomRight1 = (
          x0 <= x1 + w1 && x1 + w1 <= x0 + w0 &&
          y0 <= y1 + h1 && y1 + h1 <= y0 + h0
        );
        return topLeft0 || topRight0 || bottomLeft0 || bottomRight0 || topLeft1 || topRight1 || bottomLeft1 || bottomRight1;
      }

      function renderPlayerMovementAnimation() {
        var p = game.player.movementTimer == null ? 0 : game.player.movementTimer.getOverallProgress();
        var gameXY = tileToGameXY({
          x : game.player.currentTile.x * (1-p) + game.player.nextTile.x * p,
          y : game.player.currentTile.y * (1-p) + game.player.nextTile.y * p,
        });
        game.player.x = gameXY.x;
        game.player.y = gameXY.y;

        game.compass.circle.x = game.player.x;
        game.compass.circle.y = game.player.y;

        game.minimap.playerDot.x = game.minimap.x + game.player.x*game.minimap.scale;
        game.minimap.playerDot.y = game.minimap.y + game.player.y*game.minimap.scale;
        game.minimap.cameraBox.x = game.minimap.x + game.camera.scrollX * game.minimap.scale;
        game.minimap.cameraBox.y = game.minimap.y + game.camera.scrollY * game.minimap.scale;

        if (objectsOverlaps(game.player, game.instructionText)) {
          game.instructionText.setAlpha(0.25);
        } else {
          game.instructionText.setAlpha(1.0);
        }
        if (objectsOverlaps(game.player, game.scoreText)) {
          game.scoreText.setAlpha(0.25);
        } else {
          game.scoreText.setAlpha(1.0);
        }
        if (objectsOverlaps(game.player, game.minimap)) {
          game.minimap.setAlpha(0.25);
          game.minimap.cameraBox.setAlpha(0.25);
          game.minimap.playerDot.setAlpha(0.25);
          game.minimap.playerGoal.setAlpha(0.25);
          game.minimap.robotDot.setAlpha(0.25);
          if (game.minimap.robotGoal != null) {
            game.minimap.robotGoal.setAlpha(0.25);
          }
        } else {
          game.minimap.setAlpha(1.0);
          game.minimap.cameraBox.setAlpha(1.0);
          game.minimap.playerDot.setAlpha(1.0);
          game.minimap.playerGoal.setAlpha(1.0);
          game.minimap.robotDot.setAlpha(1.0);
          if (game.minimap.robotGoal != null) {
            game.minimap.robotGoal.setAlpha(1.0);
          }
        }

        if (game.player.taskPlan == null || game.player.taskPlan.length == 0) {
          game.compass.playerArrow.setVisible(false);
          game.compass.playerGoalText.setVisible(false);
        } else if (game.player.taskI < game.tasks.tasks.length) {
          game.compass.playerArrow.setVisible(true);
          var goal = game.player.taskPlan[game.player.taskPlan.length - 1];
          var rotation = Math.atan2(goal.y - game.player.currentTile.y, goal.x - game.player.currentTile.x)
          game.compass.playerArrow.rotation = rotation;
          game.compass.playerArrow.x = game.compass.circle.x;
          game.compass.playerArrow.y = game.compass.circle.y;

          game.compass.playerGoalText.setVisible(true);
          game.compass.playerGoalText.text = game.tasks.tasks[game.player.taskI].semanticLabel + "\nDist: ~"+game.player.taskPlan.length;
          var origin = rotationToOrigin(rotation);
          game.compass.playerGoalText.setOrigin(origin.x, origin.y);
          game.compass.playerGoalText.x = game.compass.playerArrow.x + game.compass.radius*Math.cos(rotation);
          game.compass.playerGoalText.y = game.compass.playerArrow.y + game.compass.radius*Math.sin(rotation);
        }

        if (game.robot.isBeingLed && game.robot.taskPlan != null && game.robot.taskPlan.length > 0) {
          game.compass.robotArrow.setVisible(true);
          var goal = game.robot.taskPlan[game.robot.taskPlan.length - 1];
          console.log("game.robot.taskPlan", game.robot.taskPlan, goal);
          var rotation = Math.atan2(goal.y - game.player.currentTile.y, goal.x - game.player.currentTile.x)
          game.compass.robotArrow.rotation = rotation;
          game.compass.robotArrow.x = game.compass.circle.x;
          game.compass.robotArrow.y = game.compass.circle.y;

          game.compass.robotGoalText.setVisible(true);
          game.compass.robotGoalText.text = game.tasks.robotActions[game.robot.currentActionI].robotAction.targetSemanticLabel + "\nDist: ~"+game.robot.taskPlan.length;
          var origin = rotationToOrigin(rotation);
          game.compass.robotGoalText.setOrigin(origin.x, origin.y);
          game.compass.robotGoalText.x = game.compass.robotArrow.x + game.compass.radius*Math.cos(rotation);
          game.compass.robotGoalText.y = game.compass.robotArrow.y + game.compass.radius*Math.sin(rotation);
        } else {
          game.compass.robotArrow.setVisible(false);
          game.compass.robotGoalText.setVisible(false);
        }

        if (game.player.movementTimer == null) {
          game.player.previousTile = game.player.currentTile;
        }
        if (game.player.movementTimer != null && game.player.movementTimer.getOverallProgress() == 1.0) {
          game.player.currentTile = game.player.nextTile;
          game.player.movementTimer = null;
          // Log the game state
          if (!load) logData(logGameStateEndpoint, getGameState());
        }
      }

      function renderRobotMovementAnimation() {
        var p = game.robot.movementTimer == null ? 0 : game.robot.movementTimer.getOverallProgress();
        var gameXY = tileToGameXY({
          x : game.robot.currentTile.x * (1-p) + (game.robot.plan == null || game.robot.plan.length == 0 ? game.robot.currentTile.x * p : game.robot.plan[0].x * p),
          y : game.robot.currentTile.y * (1-p) + (game.robot.plan == null || game.robot.plan.length == 0 ? game.robot.currentTile.y * p : game.robot.plan[0].y * p),
        });
        game.robot.x = gameXY.x;
        game.robot.y = gameXY.y;
        if (!isOffCamera(game.robot.currentTile, 0) && game.robot.currentTile.x >= 0 && game.robot.currentTile.y >= 0) {
          game.minimap.robotDot.setVisible(true);
          game.minimap.robotDot.x = game.minimap.x + game.robot.x*game.minimap.scale;
          game.minimap.robotDot.y = game.minimap.y + game.robot.y*game.minimap.scale;
        } else {
          game.minimap.robotDot.setVisible(false);
        }
        game.robot.helpBubble.setPosition(game.robot.x + game.robot.width / 3, game.robot.y - game.robot.height/3);
        if (game.robot.movementTimer == null) {
          game.robot.previousTile = game.robot.currentTile;
        }
        if (game.robot.movementTimer != null && game.robot.movementTimer.getOverallProgress() == 1.0) {
          if (game.robot.plan != null && game.robot.plan.length > 0) {
            game.robot.currentTile = game.robot.plan[0];
          }
          game.robot.plan.splice(0,1);
          game.robot.movementTimer = null;
          // Log the game state
          if (!load) logData(logGameStateEndpoint, getGameState());
        }
      }

      function getCurrentTaskPlan() {
        if (game.player.taskI >= game.tasks.tasks.length) {
          game.player.taskPlan = [];
          return game.player.taskPlan;
        }
        var goal = game.tasks.tasks[game.player.taskI].semanticLabel;
        var currLoc = game.player.currentTile;
        var goalLocs = game.semanticLabelsToXY[goal];
        var heuristicGoal = goalLocs[Math.floor(Math.random() * goalLocs.length)];
        if (game.player.taskPlan != null && game.player.taskPlan.length > 0) {
          heuristicGoal = game.player.taskPlan[game.player.taskPlan.length - 1];
        }
        // var goalLocs = game.semanticLabelsToXY[goal+pointOfInterestString];
        // var heuristicGoal = goalLocs[0];
        game.player.elapsedDistanceSinceComputingTaskPlan = 0;
        game.player.taskPlan = generatePlan(currLoc, goalLocs, heuristicGoal, isValidTile)
        return game.player.taskPlan;
      }

      function getCurrentPlanToRobotGoal() {
        if (!game.robot.isBeingLed) {
          game.robot.taskPlan = [];
          return game.robot.taskPlan;
        }
        var goal = game.tasks.robotActions[game.robot.currentActionI].robotAction.targetSemanticLabel;
        console.log("goal", goal);
        var currLoc = game.player.currentTile;
        var goalLocs = game.semanticLabelsToXY[goal];
        var heuristicGoal = goalLocs[Math.floor(Math.random() * goalLocs.length)];
        if (game.robot.taskPlan != null && game.robot.taskPlan.length > 0) {
          heuristicGoal = game.robot.taskPlan[game.robot.taskPlan.length - 1];
        }
        console.log("getCurrentPlanToRobotGoal", currLoc, goalLocs, heuristicGoal, isValidTile);
        console.log("getCurrentPlanToRobotGoal game.robot.taskPlan A", game.robot.taskPlan);
        game.robot.elapsedDistanceSinceComputingTaskPlan = 0;
        game.robot.taskPlan = generatePlan(currLoc, goalLocs, heuristicGoal, isValidTile);
        console.log("getCurrentPlanToRobotGoal game.robot.taskPlan B", game.robot.taskPlan);
        return game.robot.taskPlan;
      }

      // function distance(tile0, tile1) {
      //   return Math.max(Math.abs(tile0.x-tile1.x), Math.abs(tile0.y-tile1.y));
      // }

      function getCameraBounds() {
        var cameraCenterTileI = {
            x : Math.floor(game.camera.scrollX / tileSize),
            y : Math.floor(game.camera.scrollY / tileSize),
        }
        var cameraLeft = cameraCenterTileI.x; // inclusive
        var cameraRight = cameraCenterTileI.x + game.camera.width / tileSize; // exclusive
        var cameraUp = cameraCenterTileI.y; // inclusive
        var cameraDown = cameraCenterTileI.y + game.camera.height / tileSize; // exclusive

        return {
          left: cameraLeft,
          right: cameraRight,
          up: cameraUp,
          down: cameraDown,
        }
      }

      function getOffScreenTileInDirectionOfHumanMotion(opposite) {

        // if (useRobotCurrentPosition) {
        //   return closestPointWithinConstraints(game.robot.currentTile, goalConstraints, pathConstraints);
        // }

        // Get the predicted human plan to the goal
        getCurrentTaskPlan();
        // Get the point of the plan that goes off screen
        var robotSpawnNear = {
          x : game.player.currentTile.x,
          y : game.player.currentTile.y,
        };
        for (planPoint of game.player.taskPlan) {
          robotSpawnNear.x = planPoint.x;
          robotSpawnNear.y = planPoint.y;
          // If the plan point goes off the visible screen
          if (isOffCamera(planPoint)) {
              break;
          }
        }

        if (opposite) {
          // Get the camera bounds
          var cameraBounds = getCameraBounds();

          var robotSpawnNearLeft = robotSpawnNear.x < cameraBounds.left - cameraPadding;
          var robotSpawnNearRight = robotSpawnNear.x >= cameraBounds.right + cameraPadding;
          var robotSpawnNearUp = robotSpawnNear.y < cameraBounds.up - cameraPadding;
          var robotSpawnNearDown = robotSpawnNear.y >= cameraBounds.down + cameraPadding;
          if (!(robotSpawnNearLeft || robotSpawnNearRight || robotSpawnNearUp || robotSpawnNearDown)) {
            robotSpawnNearLeft = game.robot.tileAtBeginningOfWalkPast.x < game.player.currentTile.x;
            robotSpawnNearRight = game.robot.tileAtBeginningOfWalkPast.x > game.player.currentTile.x;
            robotSpawnNearUp = game.robot.tileAtBeginningOfWalkPast.y < game.player.currentTile.y;
            robotSpawnNearDown = game.robot.tileAtBeginningOfWalkPast.y > game.player.currentTile.y;
          }
          // The robot spawn point must be:
          // 1) > cameraPadding units off-screen, 2) is in a Hallway, and
          // 3) in the opposite direction of robotSpawnNear
          function goalConstraints(tile) {
            var tileLeft = tile.x < cameraBounds.left - cameraPadding;
            var tileRight = tile.x >= cameraBounds.right + cameraPadding;
            var tileUp = tile.y < cameraBounds.up - cameraPadding;
            var tileDown = tile.y >= cameraBounds.down + cameraPadding;

            var isOffCamera =  tileLeft || tileRight || tileUp || tileDown;

            var key = String([tile.x, tile.y]);
            var isInHallway = (key in game.xyToSemanticLabels &&
                               game.xyToSemanticLabels[key].has("Hallway"));

            var isInOppositeDirection = !(tileLeft && robotSpawnNearLeft) && !(tileRight && robotSpawnNearRight) && !(tileUp && robotSpawnNearUp) && !(tileDown && robotSpawnNearDown);

            return isOffCamera && isInHallway && isInOppositeDirection;
          }
          function pathConstraints(tile) {
            return true;
          }
          return closestPointWithinConstraints(game.player.currentTile/*game.robot.currentTile*/, goalConstraints, pathConstraints, 40*screenSizeX*screenSizeY);

        } else {

          // The point must be the closest point to
          // robotSpawnNear (or the robot's currentTile) that is also:
          // 1) > cameraPadding units off-screen, and 2) is in a Hallway
          function goalConstraints(tile) {
            var key = String([tile.x, tile.y]);
            var isInHallway = (key in game.xyToSemanticLabels &&
                               game.xyToSemanticLabels[key].has("Hallway"));
            return isOffCamera(tile) && isInHallway;
          }
          function pathConstraints(tile) {
            return isOffCamera(tile);
          }

          return closestPointWithinConstraints(robotSpawnNear, goalConstraints, pathConstraints, 40*screenSizeX*screenSizeY);
        }
      }

      function getOffScreenTile() {

        // The point must be the closest point to
        // robot current position (or the robot's currentTile) that is also:
        // 1) > cameraPadding units off-screen, and 2) is in a Hallway
        function goalConstraints(tile) {
          var key = String([tile.x, tile.y]);
          var isInHallway = (key in game.xyToSemanticLabels &&
                             game.xyToSemanticLabels[key].has("Hallway"));
          return isOffCamera(tile) && isInHallway;
        }
        function pathConstraints(tile) {
          return true;
        }

        return closestPointWithinConstraints(game.robot.currentTile, goalConstraints, pathConstraints, 40*screenSizeX*screenSizeY);
      }

      function createRobotGoalRect() {
        game.minimap.robotGoal = this.add.graphics({ x: 0, y: 0 });
        game.minimap.robotGoal.lineStyle(4, robotColor, 0.85);
        game.minimap.robotGoal.setScrollFactor(0.0, 0.0);
        game.minimap.robotGoal.setDepth(15);
      }

      function setHelpBubbleToAmIHere() {
        game.robot.helpBubble.setText("Excuse me. Am I in front of " + game.tasks.robotActions[game.robot.currentActionI].robotAction.targetStr + " (see map below)?");
        game.robot.helpBubble.setButtons([
          {
            text : "Yes",
            rowI: 0,
            callbackFunction : function() {
              game.robot.helpBubble.setText("Thank you.");
              game.robot.helpBubble.setButtons([]);
              setRobotState(robotState.WALK_PAST_HUMAN);
              setRobotActionInProgress(false);
              game.minimap.robotGoal.destroy();
            },
          },
          {
            text : "No",
            rowI: 0,
            callbackFunction : function() {
              game.robot.helpBubble.setText("Thank you.");
              game.robot.helpBubble.setButtons([]);
              setRobotState(robotState.WALK_PAST_HUMAN);
              setRobotActionInProgress(false);
              game.minimap.robotGoal.destroy();
            },
          },
          {
            text : "Don't Know",
            rowI: 1,
            callbackFunction : function() {
              game.robot.helpBubble.setText("Thank you.");
              game.robot.helpBubble.setButtons([]);
              setRobotState(robotState.WALK_PAST_HUMAN);
              setRobotActionInProgress(false);
              game.minimap.robotGoal.destroy();
            },
          },
          {
            text : "Can't Help",
            rowI: 1,
            callbackFunction : function() {
              game.robot.helpBubble.setText("That's okay.");
              game.robot.helpBubble.setButtons([]);
              setRobotState(robotState.WALK_PAST_HUMAN);
              setRobotActionInProgress(false);
              game.minimap.robotGoal.destroy();
            },
          },
        ]);
        var robotGoalRect = game.semanticLabelToRoomRectBounds[game.tasks.robotActions[game.robot.currentActionI].robotAction.targetSemanticLabel];
        this.createRobotGoalRect();
        game.minimap.robotGoal.strokeRect(game.minimap.x+robotGoalRect.x*game.minimap.scale, game.minimap.y+robotGoalRect.y*game.minimap.scale, robotGoalRect.width*game.minimap.scale, robotGoalRect.height*game.minimap.scale);
      }

      function setHelpBubbleToLeadMe(hasSaidYes, scene) {
        if (!hasSaidYes) {
          game.robot.helpBubble.setText("Excuse me. Can you lead me towards " + game.tasks.robotActions[game.robot.currentActionI].robotAction.targetStr + "?");
          game.robot.helpBubble.setButtons([
            {
              text : "Yes",
              rowI: 0,
              callbackFunction : function() {
                setHelpBubbleToLeadMe(true, scene);
                game.robot.isBeingLed = true;
                getCurrentPlanToRobotGoal();
                setRobotState(robotState.APPROACH_HUMAN);
              },
            },
            {
              text : "Can't Help",
              rowI: 0,
              callbackFunction : function() {
                game.robot.helpBubble.setText("That's okay.");
                game.robot.helpBubble.setButtons([]);
                setRobotState(robotState.WALK_PAST_HUMAN);
                setRobotActionInProgress(false);
                game.minimap.robotGoal.destroy();
              },
            },
          ]);
          console.log("leadme", game.tasks.robotActions[game.robot.currentActionI].robotAction.targetSemanticLabel, game.semanticLabelToRoomRectBounds, game.semanticLabelToRoomRectBounds[game.tasks.robotActions[game.robot.currentActionI].robotAction.targetSemanticLabel]);
          var robotGoalRect = game.semanticLabelToRoomRectBounds[game.tasks.robotActions[game.robot.currentActionI].robotAction.targetSemanticLabel];
          scene.createRobotGoalRect();
          game.minimap.robotGoal.strokeRect(game.minimap.x+robotGoalRect.x*game.minimap.scale, game.minimap.y+robotGoalRect.y*game.minimap.scale, robotGoalRect.width*game.minimap.scale, robotGoalRect.height*game.minimap.scale);
        } else {
          game.robot.helpBubble.setText("Thank you for leading me towards " + game.tasks.robotActions[game.robot.currentActionI].robotAction.targetStr + ". Tell me when I should stop following you.");
          game.robot.helpBubble.setButtons([
            {
              text : "Stop Following",
              rowI: 0,
              callbackFunction : function() {
                game.robot.helpBubble.setText("Thank you.");
                game.robot.helpBubble.setButtons([]);
                game.robot.isBeingLed = false;
                game.robot.taskPlan = [];
                // console.log("game.tasks.robotActions[game.robot.currentActionI].robotAction.targetStr", game.tasks.robotActions[game.robot.currentActionI].robotAction.targetStr);
                // console.log("game.semanticLabelsToXY[game.tasks.robotActions[game.robot.currentActionI].robotAction.targetStr]", game.semanticLabelsToXY[game.tasks.robotActions[game.robot.currentActionI].robotAction.targetStr]);
                var goalSemanticLabel = game.tasks.robotActions[game.robot.currentActionI].robotAction.targetSemanticLabel + pointOfInterestString + "1";
                var goalLocs = game.semanticLabelsToXY[goalSemanticLabel];
                console.log("stop following", goalSemanticLabel, goalLocs, game.semanticLabelsToXY);
                game.robot.goalTile = goalLocs[Math.floor(Math.random() * goalLocs.length)]
                if (game.robot.movementTimer != null) {
                  // If we're in the middle of a movement, set the currentTile to the tile it is going towards
                  if (game.robot.plan != null && game.robot.plan.length > 0) {
                    game.robot.currentTile = game.robot.plan[0];
                  }
                }
                game.robot.plan = generatePlan(game.robot.currentTile, [game.robot.goalTile], game.robot.goalTile, isValidTile);
                setRobotState(robotState.GO_TOWARDS_GOAL); // TODO (amal): might the user expect the robot to go into the target room, instead of just walking away?
                setRobotActionInProgress(false);
                console.log("about to destroy in stop following", game.minimap.robotGoal);
                game.minimap.robotGoal.destroy();
                console.log("destroyed in stop following", game.minimap.robotGoal);
              },
            },
          ]);
        }
      }

      function setRobotState(state) {
        // if (!game.hasRobotStateChangedThisUpdate) {
        //   game.robot.previousState = game.robot.currentState;
        //   game.hasRobotStateChangedThisUpdate = true;
        // }
        game.robot.currentState = state;
      }

      function isOffCamera(tile, padding) {
        if (padding == null) {
          padding = cameraPadding;
        }
        var cameraBounds = getCameraBounds();
        return (tile.x < cameraBounds.left - padding ||
                tile.x >= cameraBounds.right + padding ||
                tile.y < cameraBounds.up - padding ||
                tile.y >= cameraBounds.down + padding);
      }

      function setRobotActionInProgress(val) {
        if (game.robot.actionInProgress && !val) {
          game.robot.currentActionI++;
        }
        game.robot.actionInProgress = val;
      }

      function initializeGamePlayerTimer(scene) {
        game.player.negativeScoreTimer = null;
        game.player.timer = scene.time.addEvent({
          delay: game.tasks.tasks[game.player.taskI].timeLimit*1000,
          loop: false,
          callback: function() {
            game.player.negativeScoreTimer = scene.time.addEvent({
              delay: 500, // 0.5 sec
              loop: true,
              callback: function() {
                if (game.negativeScoreRedOutline.visible) {
                  game.negativeScoreRedOutline.setVisible(false);
                  game.scoreText.setFill("#ececec");
                  game.player.score -= 1;
                } else {
                  game.negativeScoreRedOutline.setVisible(true);
                  game.scoreText.setFill("#ff0000");
                }
              },
            });
          },
        });
      }

      function updateHighlightBox() {
        if (game.player.taskI < game.tasks.tasks.length) {
          game.highlightBox.setVisible(true);
          var targetStr = game.tasks.tasks[game.player.taskI].semanticLabel + highlightPointString + game.tasks.tasks[game.player.taskI].target;
          var targetTile = game.semanticLabelsToXY[targetStr][0];
          game.highlightBox.x = targetTile.x*tileSize;
          game.highlightBox.y = targetTile.y*tileSize;
          game.minimap.playerGoal.x = game.minimap.x+(game.highlightBox.x+32)*game.minimap.scale;
          game.minimap.playerGoal.y = game.minimap.y+(game.highlightBox.y+32)*game.minimap.scale;
        } else {
          game.highlightBox.setVisible(false);
          game.minimap.playerGoal.setVisible(false);
        }
      }

      function update(time, delta) {

        if (load) {
          if (dataToLoad.length > 0) {
            var dtime = Date.now() - game.start_time;
            while (dataToLoad.length > 1) {

              console.log("dtime", dtime, "dataToLoad[0].dtime", dataToLoad[0].dtime);

              game.player.currentTile = dataToLoad[0].player.currentTile;
              game.player.nextTile = dataToLoad[0].player.nextTile;
              if (lastLoadedData == null || game.player.anims.getCurrentKey() != lastLoadedData.player_anim_key) game.player.anims.play(dataToLoad[0].player_anim_key, true);
              if (!dataToLoad[0].player_anim_is_playing) game.player.anims.stop();

              game.robot.currentTile = dataToLoad[0].robot.currentTile;
              game.robot.plan = dataToLoad[0].robot.plan;

              if (!dataToLoad[0].active_player_movement_timer) {
                game.player.movementTimer = null;
              } else if (lastLoadedData != null && dataToLoad[0].active_player_movement_timer && !lastLoadedData.active_player_movement_timer && game.player.movementTimer == null) {
                game.player.movementTimer = this.time.addEvent({delay: playerMsPerStep});
              }

              this.renderPlayerMovementAnimation();
              if (game.player.movementTimer == null) {
                if (hasCompletedCurrentNavigationTask()) {
                  game.player.taskI++;
                  regenerateInstructionText();
                }
                var gameXY = tileToGameXY(game.player.currentTile);
                game.player.x = gameXY.x;
                game.player.y = gameXY.y;
              }

              if (!dataToLoad[0].active_robot_movement_timer) {
                game.robot.movementTimer = null;
              } else if (lastLoadedData != null && dataToLoad[0].active_robot_movement_timer && !lastLoadedData.active_robot_movement_timer && game.robot.movementTimer == null) {
                game.robot.movementTimer = this.time.addEvent({delay: robotMsPerStep});
              }

              renderRobotMovementAnimation();
              if (game.robot.movementTimer == null) {
                var gameXY = tileToGameXY(game.robot.currentTile);
                game.robot.x = gameXY.x;
                game.robot.y = gameXY.y;
              }

              var next_dtime = dataToLoad[1].dtime;
              if (dtime >= next_dtime) {
                lastLoadedData = dataToLoad.splice(0, 1);
              } else {
                lastLoadedData = dataToLoad[0];
                break;
              }
            }

            if (dataToLoad.length == 1) {
              console.log("Finished Playback!");
              dataToLoad = []
            }
          }
        } else {

          if (game.isRunning) {
            regenerateInstructionText();
            regenerateScoreText();

            // If we are in the middle of rendering a player movement animation
            var hadMovementTimer = game.player.movementTimer != null;
            var completedMovement = false;
            this.renderPlayerMovementAnimation();
            completedMovement = hadMovementTimer && game.player.movementTimer == null;

            if (completedMovement || !hadMovementTimer) {
              game.player.elapsedDistanceSinceComputingTaskPlan++;
              game.robot.elapsedDistanceSinceComputingTaskPlan++;
              // Check if we have completed a navigation task
              if (game.player.currentState == playerState.NAVIGATION_TASK && hasCompletedCurrentNavigationTask()) {
                game.player.currentState = playerState.DISTRACTION_TASK;
                game.distractionTaskTimerSecs = 0;
                game.player.hasCompletedDistractionTask = false;
                game.player.timer.destroy();
                if (game.player.taskI < game.tasks.tasks.length) {
                  if (game.player.negativeScoreTimer != null) {
                    game.scoreText.setFill("#ececec");
                    game.negativeScoreRedOutline.setVisible(false);
                    game.player.negativeScoreTimer.destroy();
                    game.player.negativeScoreTimer = null;
                  }
                }
                setRobotActionInProgress(false);
                if (game.minimap.robotGoal) {
                  game.minimap.robotGoal.destroy();
                }
                if (game.robot.currentState != robotState.OFFSCREEN && game.robot.currentState != robotState.WALK_PAST_HUMAN) {
                  setRobotState(robotState.WALK_PAST_HUMAN);
                }
              }

              // If we are in the distraction task, display the distraction task timer
              if (game.player.currentState == playerState.DISTRACTION_TASK && game.distractionTaskTimerSecs > 0 && !hasCompletedCurrentDistractionTask()) {
                setDistractionTaskBarVisible(true);
                this.drawDistractionTaskBarProgress();
              }

              // Check if we have completed a distraction task
              if (game.player.currentState == playerState.DISTRACTION_TASK && hasCompletedCurrentDistractionTask()) {
                game.player.taskI++;
                updateHighlightBox();
                game.player.score += scorePerTask;
                if (game.player.taskI < game.tasks.tasks.length) {
                  game.player.currentState = playerState.NAVIGATION_TASK;
                  initializeGamePlayerTimer(this);
                  getCurrentTaskPlan();
                  game.player.currentTaskDistance = game.player.taskPlan.length;
                } else {
                  game.player.currentState = playerState.COMPLETED_TASKS;
                  var scene = this;
                  game.endGameDelayTimer = this.time.addEvent({
                    delay: 2*1000,
                    callback: function() {
                      game.isRunning = false;
                      createEndingScreen(scene);
                    },
                  });
                }
              }

              // Update the task plans
              if (game.player.taskPlan == null || game.player.taskPlan.length == 0 || game.player.elapsedDistanceSinceComputingTaskPlan >= Math.floor(game.player.taskPlan.length/5)) {
                getCurrentTaskPlan();
              }
              if (game.robot.isBeingLed) {
                if (game.robot.taskPlan == null || game.robot.taskPlan.length == 0 || game.robot.elapsedDistanceSinceComputingTaskPlan >= Math.floor(game.robot.taskPlan.length/5)) {
                  getCurrentPlanToRobotGoal();
                }
              }

              // Initiate the robot action, if applicable
              if (!game.robot.actionInProgress && game.robot.currentState == robotState.OFFSCREEN) {
                if (game.robot.currentActionI < game.tasks.robotActions.length) {
                  var robotAction = game.tasks.robotActions[game.robot.currentActionI];
                  // Has the human completed the precondition task?
                  if (game.player.taskI == robotAction.afterHumanTaskIndex + 1) {
                    var requiredDistanceToGoal = Math.ceil(game.player.currentTaskDistance*(1.0-robotAction.humanDistanceProportionToNextGoal));
                    var oldTaskPlanDistanceFromRequiredDistance = game.player.taskPlan.length - requiredDistanceToGoal;
                    if (game.player.elapsedDistanceSinceComputingTaskPlan >= Math.floor(oldTaskPlanDistanceFromRequiredDistance*0.5)) {
                      getCurrentTaskPlan();
                      var distanceProportionToNextGoal = 1.0 - game.player.taskPlan.length/game.player.currentTaskDistance;
                      console.log("distanceProportionToNextGoal", distanceProportionToNextGoal, robotAction.humanDistanceProportionToNextGoal);
                      // Has the human traversed enough distance to trigger the robot action?
                      if (distanceProportionToNextGoal >= robotAction.humanDistanceProportionToNextGoal) {
                        setRobotActionInProgress(true);

                        var robotSpawnTile = getOffScreenTileInDirectionOfHumanMotion(false);
                        console.log("robotSpawnTile", robotSpawnTile);
                        setRobotState(robotState.STATIONARY);

                        // Spawn the robot there
                        game.robot.currentTile = robotSpawnTile;
                        game.numTimesAskedForHelp = -1;

                        // Change the helpBubbleText
                        if (game.tasks.robotActions[game.robot.currentActionI].robotAction.query == "amIHere") {
                          this.setHelpBubbleToAmIHere();
                        } else if (game.tasks.robotActions[game.robot.currentActionI].robotAction.query == "leadMe") {
                          setHelpBubbleToLeadMe(false, this);
                        } /*else if (game.tasks.robotActions[game.robot.currentActionI].robotAction.query == "walkPast") {
                          game.robot.tileAtBeginningOfWalkPast = robotSpawnTile;
                        }*/
                      }
                    }
                  }
                }
              }
            }

            // If we have finished rendering the last player movement animation
            if (game.player.movementTimer == null) {
              var newAction = false;
              var shouldLogData = false;
              if (game.cursors.left.isDown && !(game.player.currentState == playerState.DISTRACTION_TASK && game.distractionTaskTimerSecs > 0)) {
                game.player.nextTile = {
                  x : game.player.currentTile.x - 1,
                  y : game.player.currentTile.y,
                };
                game.player.anims.play('left', true);
                newAction = isValidTile(game.player.nextTile, false, true);
                shouldLogData = true;
              } else if (game.cursors.right.isDown && !(game.player.currentState == playerState.DISTRACTION_TASK && game.distractionTaskTimerSecs > 0)) {
                game.player.nextTile = {
                  x : game.player.currentTile.x + 1,
                  y : game.player.currentTile.y,
                };
                game.player.anims.play('right', true);
                newAction = isValidTile(game.player.nextTile, false, true);
                shouldLogData = true;
              } else if (game.cursors.up.isDown && !(game.player.currentState == playerState.DISTRACTION_TASK && game.distractionTaskTimerSecs > 0)) {
                game.player.nextTile = {
                  x : game.player.currentTile.x,
                  y : game.player.currentTile.y - 1,
                };
                game.player.anims.play('up', true);
                newAction = isValidTile(game.player.nextTile, false, true);
                shouldLogData = true;
              } else if (game.cursors.down.isDown && !(game.player.currentState == playerState.DISTRACTION_TASK && game.distractionTaskTimerSecs > 0)) {
                game.player.nextTile = {
                  x : game.player.currentTile.x,
                  y : game.player.currentTile.y + 1,
                };
                game.player.anims.play('down', true);
                newAction = isValidTile(game.player.nextTile, false, true);
                shouldLogData = true;
              } else {
                if (game.player.anims.isPlaying) shouldLogData = true;
                game.player.anims.stop();
              }

              // If the player is close enough to a Point of Interest to press space
              if (game.cursors.space.isDown && game.player.currentState == playerState.DISTRACTION_TASK) {
                if (game.player.currentState == playerState.DISTRACTION_TASK && game.player.taskI < game.tasks.tasks.length) {
                  var currentLocationKey = String([game.player.currentTile.x, game.player.currentTile.y]);
                  if (currentLocationKey in game.xyToSemanticLabels) {
                    var currentSemanticLabels = game.xyToSemanticLabels[currentLocationKey];
                    var goalSemanticLabel = game.tasks.tasks[game.player.taskI].semanticLabel + pointOfInterestString + game.tasks.tasks[game.player.taskI].target.toString();
                    // If the player pressed the space bar, to initiate the distraction task
                    if (currentSemanticLabels.has(goalSemanticLabel)) {

                      // game.distractionTaskTimer = this.time.addEvent({
                      //   delay: timeForDistractionTask*1000,
                      //   callback: function() {
                      //     game.player.hasCompletedDistractionTask = true;
                      //     game.distractionTaskTimer = null;
                      //     setDistractionTaskBarVisible(false);
                      //   },
                      // });

                      if (game.lastTimeSpaceHeld != null) {
                        var currentTime = Date.now();
                        game.distractionTaskTimerSecs += (currentTime - game.lastTimeSpaceHeld)/1000;
                        game.lastTimeSpaceHeld = currentTime;
                      } else {
                        game.lastTimeSpaceHeld = Date.now();
                      }
                      if (game.distractionTaskTimerSecs >= timeForDistractionTask) {
                        game.player.hasCompletedDistractionTask = true;
                        setDistractionTaskBarVisible(false);
                      }

                    }
                  }
                }
              } else if (!game.cursors.space.isDown) {
                game.lastTimeSpaceHeld = null;
              }

              if (newAction) {
                game.player.movementTimer = this.time.addEvent({delay: playerMsPerStep});
              }
              // Log the game state
              if (shouldLogData && !load) logData(logGameStateEndpoint, getGameState());
            }

            // If we are in the middle of rendering a robot movement animation
            renderRobotMovementAnimation();

            // If we have finished rendering the last robot movement animation
            if (game.robot.movementTimer == null) {
              if (game.robot.actionInProgress) {
                if (game.tasks.robotActions[game.robot.currentActionI].robotAction.query == "amIHere" ||
                    game.tasks.robotActions[game.robot.currentActionI].robotAction.query == "leadMe") {
                  // console.log("numTimesToTryAskingForHelp", game.numTimesAskedForHelp, numTimesToTryAskingForHelp, distance(game.robot.currentTile, game.player.currentTile), game.robot.isBeingLed);
                  if (game.numTimesAskedForHelp >= numTimesToTryAskingForHelp) {
                    setHelpBubbleVisible(false);
                    setRobotState(robotState.WALK_PAST_HUMAN);
                    setRobotActionInProgress(false);
                    console.log("human walked away about to destroy", game.minimap.robotGoal);
                    game.minimap.robotGoal.destroy();
                    console.log("human walked away destroyed", game.minimap.robotGoal);
                  } else {

                    if (!game.robot.isBeingLed) {
                      // If the human is far enough from you to try moving towards
                      // them again, do so
                      if (distance(game.robot.currentTile, game.player.currentTile) >= moveTowardsHumanDistance) {
                        setHelpBubbleVisible(false);
                        if (game.robot.currentState == robotState.STATIONARY) {
                          game.numTimesAskedForHelp += 1;
                        }
                        setRobotState(robotState.APPROACH_HUMAN);
                      }

                      // If the human is too far away from you to answer the query,
                      // make the query invisible.
                      // if (distance(game.robot.currentTile, game.player.currentTile) >= queryAnsweringDistance) {
                      //     setHelpBubbleVisible(false);
                      // }

                      // When you are close enough to the human, display the query
                      // and stop moving
                      if (distance(game.robot.currentTile, game.player.currentTile) <= queryAskingDistance) {
                        setHelpBubbleVisible(true);
                        setRobotState(robotState.STATIONARY);
                      }
                    }
                  }
                } else if (game.tasks.robotActions[game.robot.currentActionI].robotAction.query == "walkPast") {
                  if (game.robot.currentState == robotState.OFFSCREEN) {
                    setRobotActionInProgress(false);
                  } else {
                    setRobotState(robotState.WALK_PAST_HUMAN);
                  }
                }
              // Else if the robot is on screen but not doing a task
            } /*else if ((game.robot.currentTile.x != game.tasks.robot_offscreen_location.x || game.robot.currentTile.y != game.tasks.robot_offscreen_location.y)) {
                // Have the robot move off-screen
                if (game.robot.currentState != robotState.OFFSCREEN) {
                  setRobotState(robotState.WALK_PAST_HUMAN);
                }
              }*/

              var robotStateToEvaluate = game.robot.currentState;
              switch(robotStateToEvaluate) {
                case robotState.OFFSCREEN:
                  game.robot.tileAtBeginningOfWalkPast = null;
                  game.robot.currentTile = {x : game.tasks.robot_offscreen_location.x, y : game.tasks.robot_offscreen_location.y};
                  game.robot.goalTile = game.robot.currentTile;
                  game.robot.plan = null;
                  break;
                case robotState.APPROACH_HUMAN:
                  game.robot.tileAtBeginningOfWalkPast = null;
                  if (game.robot.plan == null || game.robot.plan.length == 0 || game.robot.goalTile == null || game.robot.goalTile.x != game.player.currentTile.x || game.robot.goalTile.y != game.player.currentTile.y) {
                    game.robot.goalTile = game.player.currentTile;
                    game.robot.plan = generatePlan(game.robot.currentTile, [game.robot.goalTile], game.robot.goalTile, isValidTile);
                  }
                  break;
                case robotState.WALK_PAST_HUMAN:
                  console.log("game.robot.previousState", game.robot.previousState, "isOffCamera(game.robot.currentTile)", isOffCamera(game.robot.currentTile), "game.numTimesRobotOnScreen", game.numTimesRobotOnScreen);
                  // If we just transitioned to WALK_PAST, set numTimesRobotOnScreen to 0
                  if (game.robot.previousState != robotState.WALK_PAST_HUMAN) {
                    game.numTimesRobotOnScreen = 0;
                  }
                  if (isOffCamera(game.robot.currentTile) && game.numTimesRobotOnScreen > 0) {
                    setHelpBubbleVisible(false);
                    // game.hasRobotStateChangedThisUpdate = false;
                    setRobotState(robotState.OFFSCREEN);
                  } else {

                    if (!isOffCamera(game.robot.currentTile)) {
                      game.numTimesRobotOnScreen++;
                    }

                    if (game.robot.tileAtBeginningOfWalkPast == null) {
                      game.robot.tileAtBeginningOfWalkPast = game.robot.currentTile;
                    }

                    if (game.robot.previousState != robotState.WALK_PAST_HUMAN || game.robot.plan == null || game.robot.plan.length == 0 || game.player.previousTaskI != game.player.taskI) {
                      // Have the robot move off-screen
                      var tile = getOffScreenTileInDirectionOfHumanMotion(true);
                      if (tile == null) {
                        tile = getOffScreenTile();
                        if (tile == null) {
                          game.robot.goalTile = game.robot.currentTile; // stop the robot
                        } else {
                          game.robot.goalTile = tile;
                        }
                      } else {
                        game.robot.goalTile = tile;
                      }
                      game.robot.plan = generatePlan(game.robot.currentTile, [game.robot.goalTile], game.robot.goalTile, isValidTile);
                    }
                  }
                  break;
                case robotState.STATIONARY:
                  game.robot.tileAtBeginningOfWalkPast = null;
                  game.robot.goalTile = game.robot.currentTile;
                  game.robot.plan = null;
                  break;
                case robotState.LEAVE_SCREEN:
                  if (isOffCamera(game.robot.currentTile)) {
                    setHelpBubbleVisible(false);
                    // game.hasRobotStateChangedThisUpdate = false;
                    setRobotState(robotState.OFFSCREEN);
                  } else {
                    // Have the robot move off-screen
                    if (game.robot.previousState != robotState.LEAVE_SCREEN || game.robot.plan == null || game.robot.plan.length == 0 || game.player.previousTaskI != game.player.taskI) {
                      var tile = getOffScreenTile();
                      if (tile == null) {
                        game.robot.goalTile = game.robot.currentTile; // stop the robot
                      } else {
                        game.robot.goalTile = tile;
                      }
                      game.robot.plan = generatePlan(game.robot.currentTile, [game.robot.goalTile], game.robot.goalTile, isValidTile);
                    }
                  }
                  break;
                case robotState.GO_TOWARDS_GOAL:
                  if (isOffCamera(game.robot.currentTile)) {
                    setHelpBubbleVisible(false);
                    // game.hasRobotStateChangedThisUpdate = false;
                    setRobotState(robotState.OFFSCREEN);
                  }
                  break;
                default:
                  break;
              }
              game.robot.previousState = robotStateToEvaluate;

            }

            // If we have finished rendering the last robot movement animation
            if (game.robot.movementTimer == null && game.robot.plan != null && game.robot.plan.length > 0) {
              // If the robot's plan would collide with the human
              if ((game.robot.plan[0].x == game.player.currentTile.x && game.robot.plan[0].y == game.player.currentTile.y) ||
                  (game.robot.plan[0].x == game.player.nextTile.x && game.robot.plan[0].y == game.player.nextTile.y)) {
                  // If the human is in the goal position, terminate the plan
                  if (game.robot.plan.length == 1) {
                    game.robot.plan = null;
                  }
                  // Else, replan
                  else {
                    game.robot.plan = generatePlan(game.robot.currentTile, [game.robot.goalTile], game.robot.goalTile, isValidTile);
                  }

              }
              if (game.robot.plan != null) {
                game.robot.movementTimer = this.time.addEvent({delay: robotMsPerStep});
                // Log the game state
                if (!load) logData(logGameStateEndpoint, getGameState());
              }
            }
          }

        }
        // if (!game.hasRobotStateChangedThisUpdate) {
        //   game.robot.previousState = game.robot.currentState;
        // }
        game.player.previousTaskI = game.player.taskI;
      }
    </script>

  </body>
</html>
