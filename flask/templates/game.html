<!DOCTYPE html>
<html>
  <head>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.23.0/dist/phaser.min.js"></script>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
    <script src="./assets/PriorityQueue.js"></script>
  </head>
  <body>

    <script>
      const tileSize = 64;
      const screenSizeX = 13;
      const screenSizeY = 11;

      const playerMsPerStep = 200;
      const robotMsPerStep = 350;

      const playerStartTileX = 1;
      const playerStartTileY = 3;
      const robotStartTileX = 5;
      const robotStartTileY = 6;

      const baseURL = "http://0.0.0.0:8194/";
      const logGameConfigEndpoint = "log_game_config";
      const logGameStateEndpoint = "log_game_state";

      const load = {{load|default("false", false)}};
      dataToLoad = {{dataToLoad|default([], false)|tojson}};
      lastLoadedData = null;

      const config = {
        type: Phaser.AUTO, // Which renderer to use
        width: tileSize*screenSizeX, // Canvas width in pixels; must be odd multipliers so the player starts centered
        height: tileSize*screenSizeY, // Canvas height in pixels; must be odd multipliers so the player starts centered
        parent: "game-container", // ID of the DOM element to add the canvas to
        scene: {
          preload: preload,
          create: create,
          update: update
        },
        physics: {
          default: "arcade",
          arcade: {
            gravity: { y: 0 } // Top down game, so no gravity
          },
        },
      };

      const game = new Phaser.Game(config);

      function preload() {
        // Load the tiles and tile map (created in Tiled https://www.mapeditor.org/ )
        this.load.image("tiles", "./assets/tiles64x64.png");
        this.load.tilemapTiledJSON("map", "../assets/map.json");

        // Load the character
        this.load.spritesheet(
          'characters',
          'assets/character_64x96_spritesheet_bw.png',
          {frameWidth: 64, frameHeight: 96},
        );

        // Load the robot
        this.load.spritesheet(
          'robot',
          'assets/robot.png',
          {frameWidth: 64, frameHeight: 64},
        );
      }

      function tileToGameXY(tile) {
        return {x : (tile.x + 0.5) * tileSize, y : (tile.y + 0.5) * tileSize};
      }

      function gameToTileXY(gameXY) {
        return {x : Math.floor(gameXY.x / tileSize), y : Math.floor(gameXY.y / tileSize)};
      }

      function create() {
        // Create the map and its layers
        game.map = this.make.tilemap({ key: "map" });
        game.tileset = game.map.addTilesetImage("tiles64x64", "tiles");
        game.belowLayer = game.map.createStaticLayer("Below Player", game.tileset, 0, 0);
        game.worldLayer = game.map.createStaticLayer("World", game.tileset, 0, 0);
        game.aboveLayer = game.map.createStaticLayer("Above Player", game.tileset, 0, 0);
        game.aboveLayer.setDepth(10);
        // game.worldLayer.setCollisionByProperty({ collides: true });

        // Create the player
        game.player = this.physics.add.sprite(game.config.width/2, game.config.width/2, 'characters');
        game.player.setScale(0.80);
        game.player.currentTile = {x : playerStartTileX, y : playerStartTileY};
        game.player.nextTile = game.player.currentTile;
        var gameXY = tileToGameXY(game.player.currentTile);
        game.player.x = gameXY.x;
        game.player.y = gameXY.y;

        // Add collisions between the player and world layer
        // this.physics.add.collider(game.player, game.worldLayer);

        // Create the robot
        game.robot = this.physics.add.sprite(game.config.width/2, game.config.width/2, 'robot');
        game.robot.currentTile = {x : robotStartTileX, y : robotStartTileY};
        gameXY = tileToGameXY(game.robot.currentTile);
        game.robot.x = gameXY.x;
        game.robot.y = gameXY.y;

        // Create and configure the camera
        game.camera = this.cameras.main;
        game.camera.startFollow(game.player);
        game.camera.setBounds(0, 0, game.map.widthInPixels, game.map.heightInPixels);

        // Configure the keyboard input
        game.cursors = this.input.keyboard.createCursorKeys();

        // Configure the mouse click event
        // this.input.on('pointerdown', function (pointer) {
        //   game.robot.goalTile = gameToTileXY({x : game.camera.scrollX + pointer.x, y : game.camera.scrollY + pointer.y});
        //   game.robot.plan = generatePlan(game.robot.currentTile, game.robot.goalTile);
        // });

        // Create help text in the top-left corner
        this.add.text(16, 16, "Arrow keys to move", {
          font: "18px monospace",
          fill: "#ffffff",
          padding: { x: 20, y: 10 },
          backgroundColor: "#000000"
        })
        .setScrollFactor(0);

        // Create the player animations
        this.anims.create({
            key: 'down',
            frames: this.anims.generateFrameNumbers('characters', {start: 0, end: 3}),
            frameRate: 10,
            repeat: -1
        });
        this.anims.create({
            key: 'up',
            frames: this.anims.generateFrameNumbers('characters', {start: 4, end: 7}),
            frameRate: 10,
            repeat: -1
        });
        this.anims.create({
            key: 'left',
            frames: this.anims.generateFrameNumbers('characters', {start: 8, end: 11}),
            frameRate: 10,
            repeat: -1
        });
        this.anims.create({
            key: 'right',
            frames: this.anims.generateFrameNumbers('characters', {start: 12, end: 15}),
            frameRate: 10,
            repeat: -1
        });
        game.player.anims.play('down', true);

        // Render the player's bounding box
        // this.physics.world.createDebugGraphic();

        game.start_time = Date.now(); // ms

        // Log the game configuration and initial state
        if (!load) {
          logData(logGameConfigEndpoint, getGameConfig());
          logData(logGameStateEndpoint, getGameState());
        }

      }

      function getGameConfig() {
        return {
          uuid:"{{uuid}}",
          gid:"{{gid}}",
          start_time: game.start_time,
          playerMsPerStep: playerMsPerStep,
          robotMsPerStep: robotMsPerStep,
          playerStartTileX: playerStartTileX,
          playerStartTileY: playerStartTileY,
          robotStartTileX: robotStartTileX,
          robotStartTileY: robotStartTileY,
        };
      }

      function getGameState() {
        return {
          // User study details
          uuid:"{{uuid}}",
          gid:"{{gid}}",
          // Game state
          dtime: Date.now() - game.start_time,
          player: {
            currentTile: game.player.currentTile,
            nextTile: game.player.nextTile,
          },
          robot: {
            currentTile: game.robot.currentTile,
            plan: game.robot.plan,
          },
          // Animation information
          player_anim_is_playing: game.player.anims.isPlaying,
          player_anim_key: game.player.anims.getCurrentKey(),
          robot_anim_key: null,
          active_player_movement_timer: game.player.movementTimer != null,
          active_robot_movement_timer: game.robot.movementTimer != null,
        };
      }

      function logData(endpoint, data) {
        var url = baseURL + endpoint;
        // console.log("Send ", data)
        $.ajax({
          type : "POST",
          url : url,
          data: JSON.stringify(data, null, '\t'),
          contentType: 'application/json;charset=UTF-8',
          success: function(received_data, status) {
              // console.log(`${received_data} and status is ${status}`);
          }
        });
      }

      // Implements the A* algorithm to search for a path from start to the goal
      function generatePlan(startTile, endTile) {
        // Used so that each unique (x,y) pair has maximally one object in the
        // queues/sets.
        var xyToUniqueObject = {};
        xyToUniqueObject[String([startTile.x, startTile.y])] = {x : startTile.x, y : startTile.y, f : distance(endTile, startTile), dist : 0, visitedFrom : null};
        xyToUniqueObject[String([endTile.x, endTile.y])] = {x : endTile.x, y : endTile.y, f : null, dist : null, visitedFrom : null};

        // The nodes we have yet to search through
        var openNodes = new PriorityQueue((a, b) => a.f < b.f);
        openNodes.push(xyToUniqueObject[String([startTile.x, startTile.y])]);

        // The nodes we have already searched through
        var closedNodes = new Set();

        var goalReachable = false;

        while (!openNodes.isEmpty()) {
          var currNode = openNodes.pop();
          closedNodes.add(currNode);

          if (currNode.x == endTile.x && currNode.y == endTile.y) {
            goalReachable = true;
            break;
          }

          for (dNode of [{x:0,y:1},{x:1,y:0},{x:0,y:-1},{x:-1,y:0}]) {
            var childX = currNode.x + dNode.x;
            var childY = currNode.y + dNode.y;
            if (!(String([childX, childY]) in xyToUniqueObject)) {
              xyToUniqueObject[String([childX, childY])] = {x : childX, y : childY, f : null, dist : null, visitedFrom : null};
            }
            var childNode = xyToUniqueObject[String([childX, childY])];
            if (!(childNode.x == endTile.x && childNode.y == endTile.y) && !isValidTile(childNode, true, false)) {
              continue;
            }
            if (closedNodes.has(childNode)) {
              continue;
            }
            var heuristicDist = distance(endTile, childNode);
            var childDist = currNode.dist + 1;

            if (childNode.dist == null || childDist < childNode.dist) {
              childNode.dist = childDist;
              childNode.visitedFrom = currNode;
              childNode.f = childDist + heuristicDist;
              openNodes.push(childNode);
            }
          }
        }

        if (!goalReachable) {
          return [];
        }

        var plan = [];
        var currNode = xyToUniqueObject[String([endTile.x, endTile.y])];
        while (currNode.x != startTile.x || currNode.y != startTile.y) {
          plan.unshift({x : currNode.x, y : currNode.y});
          currNode = currNode.visitedFrom;
        }
        // plan.unshift({x : startTile.x, y : startTile.y});

        return plan;
      }

      function distance(tile0, tile1) {
        return Math.abs(tile0.x - tile1.x) + Math.abs(tile0.y - tile1.y);
      }

      // Return whether or not a tile is valid for the player/robot to be in.
      // includePlayer indicates whether we should treat the player as an obstacle,
      // and includeRobot indicates whether we should treat the robot as an
      // obstacle
      function isValidTile(tile, includePlayer, includeRobot) {
        return (
          tile.x >= 0 &&
          tile.x < game.map.width &&
          tile.y >= 0 &&
          tile.y < game.map.height &&
          (!includePlayer || !((tile.x == game.player.currentTile.x && tile.y == game.player.currentTile.y) || (tile.x == game.player.nextTile.x && tile.y == game.player.nextTile.y))) &&
          (!includeRobot || !((tile.x == game.robot.currentTile.x && tile.y == game.robot.currentTile.y) || (game.robot.plan != null && game.robot.plan.length > 0 && tile.x == game.robot.plan[0].x && tile.y == game.robot.plan[0].y))) &&
          game.worldLayer.getTileAt(tile.x, tile.y) == null
        )
      }

      function renderPlayerMovementAnimation() {
        var p = game.player.movementTimer.getOverallProgress();
        var gameXY = tileToGameXY({
          x : game.player.currentTile.x * (1-p) + game.player.nextTile.x * p,
          y : game.player.currentTile.y * (1-p) + game.player.nextTile.y * p,
        });
        game.player.x = gameXY.x;
        game.player.y = gameXY.y;
        if (game.player.movementTimer.getOverallProgress() == 1.0) {
            game.player.currentTile = game.player.nextTile;
            game.player.movementTimer = null;
            // Log the game state
            if (!load) logData(logGameStateEndpoint, getGameState());
        }
      }

      function renderRobotMovementAnimation() {
        var p = game.robot.movementTimer.getOverallProgress();
        var gameXY = tileToGameXY({
          x : game.robot.currentTile.x * (1-p) + game.robot.plan[0].x * p,
          y : game.robot.currentTile.y * (1-p) + game.robot.plan[0].y * p,
        });
        game.robot.x = gameXY.x;
        game.robot.y = gameXY.y;
        if (game.robot.movementTimer.getOverallProgress() == 1.0) {
            game.robot.currentTile = game.robot.plan[0];
            game.robot.plan.splice(0,1);
            game.robot.movementTimer = null;
            // Log the game state
            if (!load) logData(logGameStateEndpoint, getGameState());
        }
      }

      function update(time, delta) {

        if (load) {
          if (dataToLoad.length > 0) {
            var dtime = Date.now() - game.start_time;
            while (dataToLoad.length > 1) {

              console.log("dtime", dtime, "dataToLoad[0].dtime", dataToLoad[0].dtime);

              game.player.currentTile = dataToLoad[0].player.currentTile;
              game.player.nextTile = dataToLoad[0].player.nextTile;
              if (lastLoadedData == null || game.player.anims.getCurrentKey() != lastLoadedData.player_anim_key) game.player.anims.play(dataToLoad[0].player_anim_key, true);
              if (!dataToLoad[0].player_anim_is_playing) game.player.anims.stop();

              game.robot.currentTile = dataToLoad[0].robot.currentTile;
              game.robot.plan = dataToLoad[0].robot.plan;

              if (!dataToLoad[0].active_player_movement_timer) {
                game.player.movementTimer = null;
              } else if (lastLoadedData != null && dataToLoad[0].active_player_movement_timer && !lastLoadedData.active_player_movement_timer && game.player.movementTimer == null) {
                game.player.movementTimer = this.time.addEvent({delay: playerMsPerStep});
              }

              if (game.player.movementTimer != null) {
                renderPlayerMovementAnimation();
              } else {
                var gameXY = tileToGameXY(game.player.currentTile);
                game.player.x = gameXY.x;
                game.player.y = gameXY.y;
              }

              if (!dataToLoad[0].active_robot_movement_timer) {
                game.robot.movementTimer = null;
              } else if (lastLoadedData != null && dataToLoad[0].active_robot_movement_timer && !lastLoadedData.active_robot_movement_timer && game.robot.movementTimer == null) {
                game.robot.movementTimer = this.time.addEvent({delay: robotMsPerStep});
              }

              if (game.robot.movementTimer != null) {
                renderRobotMovementAnimation();
              } else {
                var gameXY = tileToGameXY(game.robot.currentTile);
                game.robot.x = gameXY.x;
                game.robot.y = gameXY.y;
              }

              var next_dtime = dataToLoad[1].dtime;
              if (dtime >= next_dtime) {
                lastLoadedData = dataToLoad.splice(0, 1);
              } else {
                lastLoadedData = dataToLoad[0];
                break;
              }
            }

            if (dataToLoad.length == 1) {
              console.log("Finished Playback!");
              dataToLoad = []
            }
          }
        } else {

          // If we are in the middle of rendering a player movement animation
          if (game.player.movementTimer) {
            renderPlayerMovementAnimation();
          }

          // If we have finished rendering the last player movement animation
          if (game.player.movementTimer == null) {
            var newAction = false;
            var shouldLogData = false;
            if (game.cursors.left.isDown) {
              game.player.nextTile = {
                x : game.player.currentTile.x - 1,
                y : game.player.currentTile.y,
              };
              game.player.anims.play('left', true);
              newAction = isValidTile(game.player.nextTile, false, true);
              shouldLogData = true;
            } else if (game.cursors.right.isDown) {
              game.player.nextTile = {
                x : game.player.currentTile.x + 1,
                y : game.player.currentTile.y,
              };
              game.player.anims.play('right', true);
              newAction = isValidTile(game.player.nextTile, false, true);
              shouldLogData = true;
            } else if (game.cursors.up.isDown) {
              game.player.nextTile = {
                x : game.player.currentTile.x,
                y : game.player.currentTile.y - 1,
              };
              game.player.anims.play('up', true);
              newAction = isValidTile(game.player.nextTile, false, true);
              shouldLogData = true;
            } else if (game.cursors.down.isDown) {
              game.player.nextTile = {
                x : game.player.currentTile.x,
                y : game.player.currentTile.y + 1,
              };
              game.player.anims.play('down', true);
              newAction = isValidTile(game.player.nextTile, false, true);
              shouldLogData = true;
            } else {
              if (game.player.anims.isPlaying) shouldLogData = true;
              game.player.anims.stop();
            }

            if (newAction) {
              game.player.movementTimer = this.time.addEvent({delay: playerMsPerStep});
            }
            // Log the game state
            if (shouldLogData && !load) logData(logGameStateEndpoint, getGameState());
          }

          // If we are in the middle of rendering a robot movement animation
          if (game.robot.movementTimer) {
            renderRobotMovementAnimation();
          }
          if (game.robot.movementTimer == null) {
            // Chase the human
            if (game.robot.plan == null || game.robot.plan.length == 0 || game.robot.goalTile == null || game.robot.goalTile.x != game.player.currentTile.x || game.robot.goalTile.y != game.player.currentTile.y) {
              game.robot.goalTile = game.player.currentTile;
              game.robot.plan = generatePlan(game.robot.currentTile, game.robot.goalTile);
            }
          }

          // If we have finished rendering the last robot movement animation
          if (game.robot.movementTimer == null && game.robot.plan != null && game.robot.plan.length > 0) {
            // If the robot's plan would collide with the human
            if ((game.robot.plan[0].x == game.player.currentTile.x && game.robot.plan[0].y == game.player.currentTile.y) ||
                (game.robot.plan[0].x == game.player.nextTile.x && game.robot.plan[0].y == game.player.nextTile.y)) {
                // If the human is in the goal position, terminate the plan
                if (game.robot.plan.length == 1) {
                  game.robot.plan = null;
                }
                // Else, replan
                else {
                  game.robot.plan = generatePlan(game.robot.currentTile, game.robot.goalTile);
                }

            }
            if (game.robot.plan != null) {
              game.robot.movementTimer = this.time.addEvent({delay: robotMsPerStep});
              // Log the game state
              if (!load) logData(logGameStateEndpoint, getGameState());
            }
          }
        }
      }

    </script>

  </body>
</html>
