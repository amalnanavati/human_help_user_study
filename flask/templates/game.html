<!DOCTYPE html>
<html>
  <head>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.23.0/dist/phaser.min.js"></script>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  </head>
  <body>
    <script src="{{ url_for('static', filename='game_src/titleScreen.js') }}"></script>
    <script src="{{ url_for('static', filename='game_src/map.js') }}"></script>
    <script src="{{ url_for('static', filename='game_src/player.js') }}"></script>
    <script src="{{ url_for('static', filename='game_src/robot.js') }}"></script>
    <script src="{{ url_for('static', filename='game_src/camera.js') }}"></script>
    <script src="{{ url_for('static', filename='game_src/distractionTaskBar.js') }}"></script>
    <script src="{{ url_for('static', filename='game_src/onScreenText.js') }}"></script>
    <script src="{{ url_for('static', filename='game_src/minimap.js') }}"></script>
    <script src="{{ url_for('static', filename='game_src/highlightBox.js') }}"></script>
    <script src="{{ url_for('static', filename='game_src/miscellaneous.js') }}"></script>
    <script src="{{ url_for('static', filename='game_src/endingScreen.js') }}"></script>
    <script src="{{ url_for('static', filename='game_src/PriorityQueue.js') }}"></script>
    <script src="{{ url_for('static', filename='game_src/SpeechBubble.js') }}"></script>
    <script src="{{ url_for('static', filename='game_src/planning.js') }}"></script>
    <script>
      // Screen size params
      const tileSize = 64;
      const screenSizeX = 13;
      const screenSizeY = 11;

      const gameModes = {
        GAME: 0,
        TUTORIAL: 1
      };
      const gameMode = gameModes.GAME; // gameModes.TUTORIAL;

      // Load game params
      const load = {{load|default("false", false)}};
      dataToLoad = {{dataToLoad|default([], false)|tojson}};
      lastLoadedData = null;

      const config = {
        type: Phaser.AUTO, // Which renderer to use
        width: tileSize*screenSizeX, // Canvas width in pixels; must be odd multipliers so the player starts centered
        height: tileSize*screenSizeY, // Canvas height in pixels; must be odd multipliers so the player starts centered
        parent: "game-container", // ID of the DOM element to add the canvas to
        scene: {
          preload: preload,
          create: create,
          update: update,
        },
        physics: {
          default: "arcade",
          arcade: {
            gravity: { y: 0 } // Top down game, so no gravity
          },
        },
      };

      const game = new Phaser.Game(config);

      // Load the assets that will be used in this game
      function preload() {
        // Load the tiles and tile map (created in Tiled https://www.mapeditor.org/ )
        this.load.image("tiles", "./assets/tiles2.png");
        this.load.tilemapTiledJSON("map", "../assets/map2.json");
        this.load.image("minimap", "./assets/map2.png");

        // Load the character
        this.load.spritesheet(
          'characters',
          'assets/character_64x96_spritesheet_bw.png',
          {frameWidth: 64, frameHeight: 96},
        );

        // Load the robot
        this.load.spritesheet(
          'robot',
          'assets/robot.png',
          {frameWidth: 64, frameHeight: 64},
        );

        // Load the tasks for this game ID
        this.load.json('tasks', 'assets/tasks/{{gid}}.json');
      }

      function create() {

        switch (gameMode) {
          case gameModes.GAME:
            this.game.isRunning = false;
            // Create the title screen, and specify the function to run after the
            // user clicks start
            createTitleScreen(this, startGame);
            break;
          case gameModes.TUTORIAL:
            break;
          default:
            break;
        }

      }

      function startGame(scene) {
          switch (gameMode) {
            case gameModes.GAME:
              // Create the map
              createMap(scene);

              // Load the tasks for this game ID
              scene.game.tasks = scene.cache.json.get('tasks');

              // Create the player and the robot
              createPlayer(scene);
              createRobot(scene);

              // Create the robot help bubble
              createRobotHelpBubble(scene);

              // Create and configure the camera to follow the player and not leave the map
              createCamera(scene);

              // Configure the keyboard input
              scene.game.cursors = scene.input.keyboard.createCursorKeys();

              // Create the window that is shown during the distraction task
              createDistractionTaskBar(scene);
              setDistractionTaskBarVisible(scene, false);

              // Create the top-left instruction text
              createInstructionText(scene);

              // Create the top-right score text
              createScoreText(scene);

              // Create the bottom-right minimap
              createMinimap(scene);

              // Create the box that will highlight our goal location
              createHighlightBox(scene);

              // Create the negative score red outline
              createNegativeScoreOutline(scene);

              // Start the game
              getCurrentTaskPlan(scene);
              transitionToNewTask(scene);
              scene.game.isRunning = true;
              game.start_time = Date.now(); // ms
              initializeGamePlayerTimer(scene);
              break;
            case gameModes.TUTORIAL:
              break;
            default:
              break;
          }
      }

      function update(time, delta) {
        switch (gameMode) {
          case gameModes.GAME:
            if (this.game.isRunning) {
              // Update the instruction and score text
              regenerateInstructionText(this);
              regenerateScoreText(this);

              // Render the player movement
              var wasInMiddleOfPlayerMotion = this.game.player.movementTimer != null;
              renderPlayerMovementAnimation(this);
              var isInMiddleOfPlayerMotion = this.game.player.movementTimer != null;

              // If we just ended a movement
              if (wasInMiddleOfPlayerMotion && !isInMiddleOfPlayerMotion) {
                this.game.player.elapsedDistanceSinceComputingTaskPlan++;
                this.game.robot.elapsedDistanceSinceComputingTaskPlan++;
              }

              // Nothing can change if we were and still are rendering player movement
              if (!(wasInMiddleOfPlayerMotion && isInMiddleOfPlayerMotion)) {
                // Transition the player's state
                transitionPlayerState(this);

                // Initiate the robot action if applicable
                initiateRobotActionIfApplicable(this);
              }

              // If we are not in the middle of a player movement, then check key presses
              if (!isInMiddleOfPlayerMotion) {
                processPlayerKeyPresses(this);
              }

              // Render the robot movement
              renderRobotMovementAnimation(this);
              var isInMiddleOfRobotMotion = this.game.robot.movementTimer != null;

              if (!isInMiddleOfRobotMotion) {
                if (this.game.robot.actionInProgress) {
                  executeRobotAction(this);
                }

                // Transition the robot's state
                transitionRobotState(this);

                // Move the robot according to the plan
                moveRobotAlongPlan(this);
              }
              game.player.previousTaskI = game.player.taskI;
            }
            break;
          case gameModes.TUTORIAL:
            break;
          default:
            break;
        }
      }

    </script>

  </body>
</html>
