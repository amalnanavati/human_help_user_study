<!DOCTYPE html>
<html>
  <head>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.23.0/dist/phaser.min.js"></script>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
    <script src="./assets/PriorityQueue.js"></script>
    <script src="./assets/SpeechBubble.js"></script>
    <script src="./assets/planning.js"></script>
  </head>
  <body>

    <script>
      const tileSize = 64;
      const screenSizeX = 13;
      const screenSizeY = 11;

      const playerMsPerStep = 200;
      const robotMsPerStep = 350;

      const baseURL = "http://0.0.0.0:8194/";
      const logGameConfigEndpoint = "log_game_config";
      const logGameStateEndpoint = "log_game_state";

      const queryAskingDistance = 2; // tiles, in the l-infinity norm
      // const queryAnsweringDistance = 4; // tiles, in the l-infinity norm
      const moveTowardsHumanDistance = 6; // tiles, in the l-infinity norm
      const numTimesToTryAskingForHelp = 3;
      const cameraPadding = 1; // the robot must spwn more than these units away from the camera bounds

      const robotState = {
        OFFSCREEN: 0,
        APPROACH_HUMAN: 1,
        WALK_PAST_HUMAN: 2, // walks in the opposite direction of the human, and then transitions to offscreen
        STATIONARY: 3,
        LEAVE_SCREEN: 4, // walks off the screen
        GO_TOWARDS_GOAL: 5, // goes towards the goal until its offscreen
      }

      const load = {{load|default("false", false)}};
      dataToLoad = {{dataToLoad|default([], false)|tojson}};
      lastLoadedData = null;

      const config = {
        type: Phaser.AUTO, // Which renderer to use
        width: tileSize*screenSizeX, // Canvas width in pixels; must be odd multipliers so the player starts centered
        height: tileSize*screenSizeY, // Canvas height in pixels; must be odd multipliers so the player starts centered
        parent: "game-container", // ID of the DOM element to add the canvas to
        scene: {
          preload: preload,
          create: create,
          update: update
        },
        physics: {
          default: "arcade",
          arcade: {
            gravity: { y: 0 } // Top down game, so no gravity
          },
        },
      };

      const game = new Phaser.Game(config);

      function preload() {
        // Load the tiles and tile map (created in Tiled https://www.mapeditor.org/ )
        this.load.image("tiles", "./assets/tiles64x64.png");
        this.load.tilemapTiledJSON("map", "../assets/map.json");

        // Load the character
        this.load.spritesheet(
          'characters',
          'assets/character_64x96_spritesheet_bw.png',
          {frameWidth: 64, frameHeight: 96},
        );

        // Load the robot
        this.load.spritesheet(
          'robot',
          'assets/robot.png',
          {frameWidth: 64, frameHeight: 64},
        );

        // Load the tasks for this game ID
        this.load.json('tasks', 'assets/tasks/{{gid}}.json');
      }

      function tileToGameXY(tile) {
        return {x : (tile.x + 0.5) * tileSize, y : (tile.y + 0.5) * tileSize};
      }

      function gameToTileXY(gameXY) {
        return {x : Math.floor(gameXY.x / tileSize), y : Math.floor(gameXY.y / tileSize)};
      }

      function create() {
        // Create the map and its layers
        game.map = this.make.tilemap({ key: "map" });
        game.tileset = game.map.addTilesetImage("tiles64x64", "tiles");
        game.belowLayer = game.map.createStaticLayer("Below Player", game.tileset, 0, 0);
        game.worldLayer = game.map.createStaticLayer("World", game.tileset, 0, 0);
        // game.worldLayer.setCollisionByProperty({ collides: true });
        game.aboveLayer = game.map.createStaticLayer("Above Player", game.tileset, 0, 0);
        game.aboveLayer.setDepth(10);
        // TODO (amal): preprocess this and save it in an assets json file
        game.xyToSemanticLabels = {};
        for (i = 0; i < game.map.objects.length; i++) {
          if (game.map.objects[i].name == "Objects") {
            for (j = 0; j < game.map.objects[i].objects.length; j++) {
              if (!game.map.objects[i].objects[j].rectangle) {
                continue;
              }
              var rect = game.map.objects[i].objects[j];
              for (tileX = Math.ceil(rect.x/tileSize); tileX < Math.floor((rect.x+rect.width)/tileSize); tileX++) {
                for (tileY = Math.ceil(rect.y/tileSize); tileY < Math.floor((rect.y+rect.height)/tileSize); tileY++) {
                  game.xyToSemanticLabels[String([tileX, tileY])] = rect.name;
                }
              }
            }
            break;
          }
        }
        game.semanticLabelsToXY = {};
        for (xyStr in game.xyToSemanticLabels) {
          var semanticLabel = game.xyToSemanticLabels[xyStr];
          var nums = xyStr.split(",");
          var x = parseFloat(nums[0]);
          var y = parseFloat(nums[1]);
          if (!(semanticLabel in game.semanticLabelsToXY)) {
            game.semanticLabelsToXY[semanticLabel] = [];
          }
          game.semanticLabelsToXY[semanticLabel].push({x : x, y : y});
        }

        // Load the tasks for this Game ID
        game.tasks = this.cache.json.get('tasks');

        // Create the player
        game.player = this.physics.add.sprite(game.config.width/2, game.config.width/2, 'characters');
        game.player.setScale(0.80);
        game.player.setDepth(5);
        game.player.currentTile = {x : game.tasks.player_start_location.x, y : game.tasks.player_start_location.y};
        game.player.previousTile = game.player.currentTile;
        game.player.nextTile = game.player.currentTile;
        var gameXY = tileToGameXY(game.player.currentTile);
        game.player.x = gameXY.x;
        game.player.y = gameXY.y;
        game.player.taskPlan = null;
        game.player.taskI = 0;
        game.player.previousTaskI = game.player.taskI;
        initializeGamePlayerTimer(this);
        game.player.score = 0;

        // Add collisions between the player and world layer
        // this.physics.add.collider(game.player, game.worldLayer);

        // Create the robot
        game.robot = this.physics.add.sprite(game.config.width/2, game.config.width/2, 'robot');
        game.robot.setDepth(5);
        game.robot.currentTile = {x : game.tasks.robot_offscreen_location.x, y : game.tasks.robot_offscreen_location.y};
        game.robot.previousTile = game.robot.currentTile;
        game.robot.goalTile = game.robot.currentTile;
        game.robot.plan = null;
        gameXY = tileToGameXY(game.robot.currentTile);
        game.robot.x = gameXY.x;
        game.robot.y = gameXY.y;
        game.robot.currentState = robotState.OFFSCREEN;
        // game.hasRobotStateChangedThisUpdate = false;
        setRobotState(robotState.OFFSCREEN); // repeated to properly set previousState
        game.robot.isBeingLed = false;
        game.robot.taskPlan = [];
        game.robot.currentActionI = 0;
        game.robot.actionInProgress = false;

        // Add the robot's help bubble
        game.questions = [
          "Can you tell me if I'm at the Lounge?",
          "Can you lead me towards Room 23?",
          "Am I in front of Room 11?",
          "I need help",
          "Is the room in front of me called the Lounge?",
        ];
        game.questionI = 0;
        game.robot.helpBubble = new SpeechBubble(this, 225, 300, 300, game.questions[game.questionI], [
          {
            text : "Yes",
            callbackFunction : () => console.log("Yes button clicked"),
          },
          {
            text : "No",
            callbackFunction : () => console.log("No button clicked"),
          },
        ]);
        game.robot.helpBubble.setVisible(true);

        // Create and configure the camera
        game.camera = this.cameras.main;
        game.camera.startFollow(game.player);
        game.camera.setBounds(0, 0, game.map.widthInPixels, game.map.heightInPixels);

        // Add the compass
        game.compass = {};
        game.compass.radius = 64*1.0
        game.compass.circle = this.add.graphics({ x: 0, y: 0 });
        game.compass.circle.fillStyle(0x000000, 0.5);
        game.compass.circle.lineStyle(4, 0xffffff, 0.5);
        game.compass.circle.fillCircle(0, 0, game.compass.radius);
        game.compass.circle.setDepth(3);

        game.compass.playerArrow = this.add.graphics({ x: 0, y: 0 });
        game.compass.playerArrow.lineStyle(4, 0xff0000, 0.5);
        game.compass.playerArrow.lineBetween(0, 0, game.compass.radius, 0);
        game.compass.playerArrow.setDepth(4);
        game.compass.playerGoalText = this.add.text(game.compass.radius, 0, "", {
          font: "16px monospace",
          fill: "#ff0000",
          padding: { x: 0, y: 0 },
          align: "center",
        });
        game.compass.playerGoalText.setDepth(4);

        game.compass.robotArrow = this.add.graphics({ x: 0, y: 0 });
        game.compass.robotArrow.lineStyle(4, 0x0000ff, 0.5);
        game.compass.robotArrow.lineBetween(0, 0, game.compass.radius, 0);
        game.compass.robotArrow.setDepth(4);
        game.compass.robotGoalText = this.add.text(game.compass.radius, 0, "", {
          font: "16px monospace",
          fill: "#0000ff",
          padding: { x: 0, y: 0 },
          align: "center",
        });
        game.compass.robotGoalText.setDepth(4);


        // Configure the keyboard input
        game.cursors = this.input.keyboard.createCursorKeys();

        // Configure the mouse click event -- often used for easy debugging
        this.input.on('pointerdown', function (pointer) {
          // // Set the robot goal
          // game.robot.goalTile = gameToTileXY({x : game.camera.scrollX + pointer.x, y : game.camera.scrollY + pointer.y});
          // game.robot.plan = generatePlan(game.robot.currentTile, [game.robot.goalTile], game.robot.goalTile, isValidTile);

          // // Move the speech bubble position
          // game.robot.helpBubble.setPosition(pointer.x, pointer.y);

          // // Change the speech bubble text
          // game.questionI = (game.questionI + 1) % game.questions.length;
          // game.robot.helpBubble.setText(game.questions[game.questionI]);

          // // Change the speech bubble visibility
          // game.robot.helpBubble.setVisible(!game.robot.helpBubble.getVisibile());

          // // Change the speech bubble width
          // game.questionI = (game.questionI + 1) % game.questions.length;
          // game.robot.helpBubble.setWidth(((game.questionI % 2) + 1)*200);

          // // Change the speech bubble questions
          // game.questionI++;
          // if (game.questionI % 3 == 0) {
          //   game.robot.helpBubble.setText("Excuse me. Am I at " + game.tasks.robotActions[game.robot.currentActionI].robotAction.targetStr + "?");
          //   game.robot.helpBubble.setButtons([
          //     {
          //       text : "Yes",
          //       callbackFunction : () => console.log("Yes button clicked"),
          //     },
          //     {
          //       text : "No",
          //       callbackFunction : () => console.log("No button clicked"),
          //     },
          //   ]);
          // } else if (game.questionI % 3 == 1) {
          //   game.robot.helpBubble.setText("Excuse me. Can you lead me towards " + game.tasks.robotActions[game.robot.currentActionI].robotAction.targetStr + "?");
          //   game.robot.helpBubble.setButtons([
          //     {
          //       text : "Yes",
          //       callbackFunction : () => console.log("Yes button clicked"),
          //     },
          //     {
          //       text : "No",
          //       callbackFunction : () => console.log("No button clicked"),
          //     },
          //   ]);
          // } else {
          //   game.robot.helpBubble.setText("Thank you for leading me towards " + game.tasks.robotActions[game.robot.currentActionI].robotAction.targetStr + ". Let me know when I should stop following you.");
          //   game.robot.helpBubble.setButtons([
          //     {
          //       text : "Stop Following",
          //       callbackFunction : () => console.log("Stop Following button clicked"),
          //     },
          //   ]);
          // }

          // // Cycle through robot states
          // game.robot.currentState = (game.robot.currentState + 1) % 3;
          // console.log("game.robot.currentState", game.robot.currentState);
          // if (game.robot.currentState == robotState.APPROACH_HUMAN) {
          //   var robotSpawnTile = getOffScreenTileInDirectionOfHumanMotion(false);
          //   if (robotSpawnTile != null) {
          //     // Spawn the robot there
          //     game.robot.currentTile = robotSpawnTile;
          //   } else {
          //     console.log("Failed to compute a spawn point for the robot");
          //   }
          // }
        });

        // Create help text in the top-left corner
        game.baseInstructionsStr = "Arrow keys to move";
        game.instructionText = this.add.text(16, 16, "", {
          font: "18px monospace",
          fill: "#ffffff",
          padding: { x: 20, y: 10 },
          backgroundColor: "#000000"
        });
        game.instructionText.setOrigin(0.0, 0.0); // top-left
        game.instructionText.setScrollFactor(0);
        game.instructionText.setDepth(1);
        regenerateInstructionText();

        // Create score text in the top-right corner
        game.scoreText = this.add.text(game.config.width-16, 16, "", {
          font: "18px monospace",
          fill: "#ffffff",
          padding: { x: 0, y: 0 },
          backgroundColor: "#000000"
        });
        game.scoreText.setOrigin(1.0, 0.0); // top-right
        game.scoreText.setScrollFactor(0);
        game.scoreText.setDepth(1);
        regenerateScoreText();

        // Create the player animations
        this.anims.create({
            key: 'down',
            frames: this.anims.generateFrameNumbers('characters', {start: 0, end: 3}),
            frameRate: 10,
            repeat: -1
        });
        this.anims.create({
            key: 'up',
            frames: this.anims.generateFrameNumbers('characters', {start: 4, end: 7}),
            frameRate: 10,
            repeat: -1
        });
        this.anims.create({
            key: 'left',
            frames: this.anims.generateFrameNumbers('characters', {start: 8, end: 11}),
            frameRate: 10,
            repeat: -1
        });
        this.anims.create({
            key: 'right',
            frames: this.anims.generateFrameNumbers('characters', {start: 12, end: 15}),
            frameRate: 10,
            repeat: -1
        });
        game.player.anims.play('down', true);

        // Render the player's bounding box
        // this.physics.world.createDebugGraphic();

        game.start_time = Date.now(); // ms

        getCurrentTaskPlan();
        game.player.currentTaskDistance = game.player.taskPlan.length;

        // Log the game configuration and initial state
        if (!load) {
          logData(logGameConfigEndpoint, getGameConfig());
          logData(logGameStateEndpoint, getGameState());
        }

      }

      function regenerateInstructionText() {
        game.instructionText.text = game.baseInstructionsStr;
        if (game.player.taskI < game.tasks.tasks.length) {
          game.instructionText.text += "\nGo to "+game.tasks.tasks[game.player.taskI].semanticLabel;
          var remainingSecs = Math.round((game.player.timer.delay - game.player.timer.getProgress()*game.player.timer.delay)/1000);
          game.instructionText.text += "\nWithin "+remainingSecs.toString()+" secs.";
        } else {
          game.instructionText.text += "\nCompleted tasks!";
        }
      }

      function regenerateScoreText() {
        game.scoreText.text = "Score: " + game.player.score.toString();
      }

      function hasCompletedCurrentTask() {
        if (game.player.taskI >= game.tasks.tasks.length) {
          return false;
        }
        var currentLocationKey = String([game.player.currentTile.x, game.player.currentTile.y]);
        if (currentLocationKey in game.xyToSemanticLabels) {
          var currentSemanticLabel = game.xyToSemanticLabels[currentLocationKey];
          var goalSemanticLabel = game.tasks.tasks[game.player.taskI].semanticLabel;
          return currentSemanticLabel == goalSemanticLabel;
        }
        return false;
      }

      function getGameConfig() {
        return {
          uuid:"{{uuid}}",
          gid:"{{gid}}",
          start_time: game.start_time,
          playerMsPerStep: playerMsPerStep,
          robotMsPerStep: robotMsPerStep,
        };
      }

      function getGameState() {
        return {
          // User study details
          uuid:"{{uuid}}",
          gid:"{{gid}}",
          // Game state
          dtime: Date.now() - game.start_time,
          player: {
            currentTile: game.player.currentTile,
            nextTile: game.player.nextTile,
          },
          robot: {
            currentTile: game.robot.currentTile,
            plan: game.robot.plan,
          },
          // Animation information
          player_anim_is_playing: game.player.anims.isPlaying,
          player_anim_key: game.player.anims.getCurrentKey(),
          robot_anim_key: null,
          active_player_movement_timer: game.player.movementTimer != null,
          active_robot_movement_timer: game.robot.movementTimer != null,
        };
      }

      function logData(endpoint, data) {
        var url = baseURL + endpoint;
        // console.log("Send ", data)
        $.ajax({
          type : "POST",
          url : url,
          data: JSON.stringify(data, null, '\t'),
          contentType: 'application/json;charset=UTF-8',
          success: function(received_data, status) {
              // console.log(`${received_data} and status is ${status}`);
          }
        });
      }

      // Return whether or not a tile is valid for the player/robot to be in.
      // includePlayer indicates whether we should treat the player as an obstacle,
      // and includeRobot indicates whether we should treat the robot as an
      // obstacle
      function isValidTile(tile, includePlayer, includeRobot) {
        return (
          tile.x >= 0 &&
          tile.x < game.map.width &&
          tile.y >= 0 &&
          tile.y < game.map.height &&
          (!includePlayer || !((tile.x == game.player.currentTile.x && tile.y == game.player.currentTile.y) || (tile.x == game.player.nextTile.x && tile.y == game.player.nextTile.y))) &&
          (!includeRobot || game.robot.currentTile == null || !((tile.x == game.robot.currentTile.x && tile.y == game.robot.currentTile.y) || (game.robot.plan != null && game.robot.plan.length > 0 && tile.x == game.robot.plan[0].x && tile.y == game.robot.plan[0].y))) &&
          game.worldLayer.getTileAt(tile.x, tile.y) == null
        )
      }

      function rotationToOrigin(rotation) {
        if ((rotation >= -Math.PI/4 && rotation <= 0) || (rotation <= Math.PI/4 && rotation >= 0)) {
          originX = 0;
          originY = (rotation + Math.PI/4)/(Math.PI/2);
        } else if (rotation <= -Math.PI/4 && rotation >= -3*Math.PI/4) {
          originX = (-rotation - Math.PI/4)/(Math.PI/2);
          originY = 1;
        } else if (rotation <= -3*Math.PI/4 || rotation >= 3*Math.PI/4) {
          originX = 1;
          if (rotation < 0) {
            originY = (-rotation-3*Math.PI/4)/(Math.PI/2);
          } else {
            originY = (rotation-3*Math.PI/4)/(Math.PI/2);
          }
        } else if (rotation >= Math.PI/4 && rotation <= 3*Math.PI/4) {
          originX = (rotation - Math.PI/4)/(Math.PI/2);
          originY = 0;
        } else {
          throw "rotation that did not fit in range "+rotation.toString();
        }
        return {x: originX, y: originY};
      }

      function renderPlayerMovementAnimation() {
        var p = game.player.movementTimer == null ? 0 : game.player.movementTimer.getOverallProgress();
        var gameXY = tileToGameXY({
          x : game.player.currentTile.x * (1-p) + game.player.nextTile.x * p,
          y : game.player.currentTile.y * (1-p) + game.player.nextTile.y * p,
        });
        game.player.x = gameXY.x;
        game.player.y = gameXY.y;
        game.compass.circle.x = game.player.x;
        game.compass.circle.y = game.player.y;
        if (game.player.taskPlan == null || game.player.taskPlan.length == 0) {
          game.compass.playerArrow.setVisible(false);
          game.compass.playerGoalText.setVisible(false);
        } else if (game.player.taskI < game.tasks.tasks.length) {
          game.compass.playerArrow.setVisible(true);
          var goal = game.player.taskPlan[game.player.taskPlan.length - 1];
          var rotation = Math.atan2(goal.y - game.player.currentTile.y, goal.x - game.player.currentTile.x)
          game.compass.playerArrow.rotation = rotation;
          game.compass.playerArrow.x = game.compass.circle.x;
          game.compass.playerArrow.y = game.compass.circle.y;

          game.compass.playerGoalText.setVisible(true);
          game.compass.playerGoalText.text = game.tasks.tasks[game.player.taskI].semanticLabel + "\nDist: ~"+game.player.taskPlan.length;
          var origin = rotationToOrigin(rotation);
          game.compass.playerGoalText.setOrigin(origin.x, origin.y);
          game.compass.playerGoalText.x = game.compass.playerArrow.x + game.compass.radius*Math.cos(rotation);
          game.compass.playerGoalText.y = game.compass.playerArrow.y + game.compass.radius*Math.sin(rotation);
        }
        if (game.robot.isBeingLed) {
          game.compass.robotArrow.setVisible(true);
          var goal = game.robot.taskPlan[game.robot.taskPlan.length - 1];
          console.log("game.robot.taskPlan", game.robot.taskPlan, goal);
          var rotation = Math.atan2(goal.y - game.player.currentTile.y, goal.x - game.player.currentTile.x)
          game.compass.robotArrow.rotation = rotation;
          game.compass.robotArrow.x = game.compass.circle.x;
          game.compass.robotArrow.y = game.compass.circle.y;

          game.compass.robotGoalText.setVisible(true);
          game.compass.robotGoalText.text = game.tasks.robotActions[game.robot.currentActionI].robotAction.targetSemanticLabel + "\nDist: ~"+game.robot.taskPlan.length;
          var origin = rotationToOrigin(rotation);
          game.compass.robotGoalText.setOrigin(origin.x, origin.y);
          game.compass.robotGoalText.x = game.compass.robotArrow.x + game.compass.radius*Math.cos(rotation);
          game.compass.robotGoalText.y = game.compass.robotArrow.y + game.compass.radius*Math.sin(rotation);
        } else {
          game.compass.robotArrow.setVisible(false);
          game.compass.robotGoalText.setVisible(false);
        }
        if (game.player.movementTimer == null) {
          game.player.previousTile = game.player.currentTile;
        }
        if (game.player.movementTimer != null && game.player.movementTimer.getOverallProgress() == 1.0) {
          game.player.currentTile = game.player.nextTile;
          game.player.movementTimer = null;
          // Log the game state
          if (!load) logData(logGameStateEndpoint, getGameState());
        }
      }

      function renderRobotMovementAnimation() {
        var p = game.robot.movementTimer == null ? 0 : game.robot.movementTimer.getOverallProgress();
        var gameXY = tileToGameXY({
          x : game.robot.currentTile.x * (1-p) + (game.robot.plan == null || game.robot.plan.length == 0 ? game.robot.currentTile.x * p : game.robot.plan[0].x * p),
          y : game.robot.currentTile.y * (1-p) + (game.robot.plan == null || game.robot.plan.length == 0 ? game.robot.currentTile.y * p : game.robot.plan[0].y * p),
        });
        game.robot.x = gameXY.x;
        game.robot.y = gameXY.y;
        game.robot.helpBubble.setPosition(game.robot.x + game.robot.width / 3, game.robot.y - game.robot.height/3);
        if (game.robot.movementTimer == null) {
          game.robot.previousTile = game.robot.currentTile;
        }
        if (game.robot.movementTimer != null && game.robot.movementTimer.getOverallProgress() == 1.0) {
          game.robot.currentTile = game.robot.plan[0];
          game.robot.plan.splice(0,1);
          game.robot.movementTimer = null;
          // Log the game state
          if (!load) logData(logGameStateEndpoint, getGameState());
        }
      }

      function getCurrentTaskPlan() {
        if (game.player.taskI >= game.tasks.tasks.length) {
          game.player.taskPlan = [];
          return game.player.taskPlan;
        }
        var goal = game.tasks.tasks[game.player.taskI].semanticLabel;
        var currLoc = game.player.currentTile;
        var goalLocs = game.semanticLabelsToXY[goal];
        var heuristicGoal = goalLocs[Math.floor(Math.random() * goalLocs.length)];
        if (game.player.taskPlan != null) {
          heuristicGoal = game.player.taskPlan[game.player.taskPlan.length - 1];
        }
        game.player.elapsedDistanceSinceComputingTaskPlan = 0;
        game.player.taskPlan = generatePlan(currLoc, goalLocs, heuristicGoal, isValidTile)
        return game.player.taskPlan;
      }

      function getCurrentPlanToRobotGoal() {
        if (!game.robot.isBeingLed) {
          game.robot.taskPlan = [];
          return game.robot.taskPlan;
        }
        var goal = game.tasks.robotActions[game.robot.currentActionI].robotAction.targetSemanticLabel;
        console.log("goal", goal);
        var currLoc = game.player.currentTile;
        var goalLocs = game.semanticLabelsToXY[goal];
        var heuristicGoal = goalLocs[Math.floor(Math.random() * goalLocs.length)];
        if (game.robot.taskPlan != null && game.robot.taskPlan.length > 0) {
          heuristicGoal = game.robot.taskPlan[game.robot.taskPlan.length - 1];
        }
        console.log("getCurrentPlanToRobotGoal", currLoc, goalLocs, heuristicGoal, isValidTile);
        console.log("getCurrentPlanToRobotGoal game.robot.taskPlan A", game.robot.taskPlan);
        game.robot.elapsedDistanceSinceComputingTaskPlan = 0;
        game.robot.taskPlan = generatePlan(currLoc, goalLocs, heuristicGoal, isValidTile);
        console.log("getCurrentPlanToRobotGoal game.robot.taskPlan B", game.robot.taskPlan);
        return game.robot.taskPlan;
      }

      // function distance(tile0, tile1) {
      //   return Math.max(Math.abs(tile0.x-tile1.x), Math.abs(tile0.y-tile1.y));
      // }

      function getCameraBounds() {
        var cameraCenterTileI = {
            x : Math.floor(game.camera.scrollX / tileSize),
            y : Math.floor(game.camera.scrollY / tileSize),
        }
        var cameraLeft = cameraCenterTileI.x; // inclusive
        var cameraRight = cameraCenterTileI.x + game.camera.width / tileSize; // exclusive
        var cameraUp = cameraCenterTileI.y; // inclusive
        var cameraDown = cameraCenterTileI.y + game.camera.height / tileSize; // exclusive

        return {
          left: cameraLeft,
          right: cameraRight,
          up: cameraUp,
          down: cameraDown,
        }
      }

      function getOffScreenTileInDirectionOfHumanMotion(opposite) {

        // if (useRobotCurrentPosition) {
        //   return closestPointWithinConstraints(game.robot.currentTile, goalConstraints, pathConstraints);
        // }

        // Get the predicted human plan to the goal
        getCurrentTaskPlan();
        // Get the point of the plan that goes off screen
        var robotSpawnNear = {
          x : game.player.currentTile.x,
          y : game.player.currentTile.y,
        };
        for (planPoint of game.player.taskPlan) {
          robotSpawnNear.x = planPoint.x;
          robotSpawnNear.y = planPoint.y;
          // If the plan point goes off the visible screen
          if (isOffCamera(planPoint)) {
              break;
          }
        }

        if (opposite) {
          // Get the camera bounds
          var cameraBounds = getCameraBounds();

          var robotSpawnNearLeft = robotSpawnNear.x < cameraBounds.left - cameraPadding;
          var robotSpawnNearRight = robotSpawnNear.x >= cameraBounds.right + cameraPadding;
          var robotSpawnNearUp = robotSpawnNear.y < cameraBounds.up - cameraPadding;
          var robotSpawnNearDown = robotSpawnNear.y >= cameraBounds.down + cameraPadding;
          if (!(robotSpawnNearLeft || robotSpawnNearRight || robotSpawnNearUp || robotSpawnNearDown)) {
            robotSpawnNearLeft = game.robot.tileAtBeginningOfWalkPast.x < game.player.currentTile.x;
            robotSpawnNearRight = game.robot.tileAtBeginningOfWalkPast.x > game.player.currentTile.x;
            robotSpawnNearUp = game.robot.tileAtBeginningOfWalkPast.y < game.player.currentTile.y;
            robotSpawnNearDown = game.robot.tileAtBeginningOfWalkPast.y > game.player.currentTile.y;
          }
          // The robot spawn point must be:
          // 1) > cameraPadding units off-screen, 2) is in a Hallway, and
          // 3) in the opposite direction of robotSpawnNear
          function goalConstraints(tile) {
            var tileLeft = tile.x < cameraBounds.left - cameraPadding;
            var tileRight = tile.x >= cameraBounds.right + cameraPadding;
            var tileUp = tile.y < cameraBounds.up - cameraPadding;
            var tileDown = tile.y >= cameraBounds.down + cameraPadding;

            var isOffCamera =  tileLeft || tileRight || tileUp || tileDown;

            var key = String([tile.x, tile.y]);
            var isInHallway = (key in game.xyToSemanticLabels &&
                               game.xyToSemanticLabels[key] == "Hallway");

            var isInOppositeDirection = !(tileLeft && robotSpawnNearLeft) && !(tileRight && robotSpawnNearRight) && !(tileUp && robotSpawnNearUp) && !(tileDown && robotSpawnNearDown);

            return isOffCamera && isInHallway && isInOppositeDirection;
          }
          function pathConstraints(tile) {
            return true;
          }
          return closestPointWithinConstraints(game.player.currentTile/*game.robot.currentTile*/, goalConstraints, pathConstraints, 40*screenSizeX*screenSizeY);

        } else {

          // The point must be the closest point to
          // robotSpawnNear (or the robot's currentTile) that is also:
          // 1) > cameraPadding units off-screen, and 2) is in a Hallway
          function goalConstraints(tile) {
            var key = String([tile.x, tile.y]);
            var isInHallway = (key in game.xyToSemanticLabels &&
                               game.xyToSemanticLabels[key] == "Hallway");
            return isOffCamera(tile) && isInHallway;
          }
          function pathConstraints(tile) {
            return isOffCamera(tile);
          }

          return closestPointWithinConstraints(robotSpawnNear, goalConstraints, pathConstraints, 40*screenSizeX*screenSizeY);
        }
      }

      function getOffScreenTile() {

        // The point must be the closest point to
        // robot current position (or the robot's currentTile) that is also:
        // 1) > cameraPadding units off-screen, and 2) is in a Hallway
        function goalConstraints(tile) {
          var key = String([tile.x, tile.y]);
          var isInHallway = (key in game.xyToSemanticLabels &&
                             game.xyToSemanticLabels[key] == "Hallway");
          return isOffCamera(tile) && isInHallway;
        }
        function pathConstraints(tile) {
          return true;
        }

        return closestPointWithinConstraints(game.robot.currentTile, goalConstraints, pathConstraints, 40*screenSizeX*screenSizeY);
      }

      function setHelpBubbleToAmIHere() {
        game.robot.helpBubble.setText("Excuse me. Am I at " + game.tasks.robotActions[game.robot.currentActionI].robotAction.targetStr + "?");
        game.robot.helpBubble.setButtons([
          {
            text : "Yes",
            callbackFunction : function() {
              game.robot.helpBubble.setText("Thank you.");
              game.robot.helpBubble.setButtons([]);
              setRobotState(robotState.WALK_PAST_HUMAN);
              setRobotActionInProgress(false);
            },
          },
          {
            text : "No",
            callbackFunction : function() {
              game.robot.helpBubble.setText("Thank you.");
              game.robot.helpBubble.setButtons([]);
              setRobotState(robotState.WALK_PAST_HUMAN);
              setRobotActionInProgress(false);
            },
          },
        ]);
      }
      function setHelpBubbleToLeadMe(hasSaidYes) {
        if (!hasSaidYes) {
          game.robot.helpBubble.setText("Excuse me. Can you lead me towards " + game.tasks.robotActions[game.robot.currentActionI].robotAction.targetStr + "?");
          game.robot.helpBubble.setButtons([
            {
              text : "Yes",
              callbackFunction : function() {
                setHelpBubbleToLeadMe(true);
                game.robot.isBeingLed = true;
                getCurrentPlanToRobotGoal();
                setRobotState(robotState.APPROACH_HUMAN);
              },
            },
            {
              text : "No",
              callbackFunction : function() {
                game.robot.helpBubble.setText("That's okay.");
                game.robot.helpBubble.setButtons([]);
                setRobotState(robotState.WALK_PAST_HUMAN);
                setRobotActionInProgress(false);
              },
            },
          ]);
        } else {
          game.robot.helpBubble.setText("Thank you for leading me towards " + game.tasks.robotActions[game.robot.currentActionI].robotAction.targetStr + ". Tell me when I should stop following you.");
          game.robot.helpBubble.setButtons([
            {
              text : "Stop Following",
              callbackFunction : function() {
                game.robot.helpBubble.setText("Thank you.");
                game.robot.helpBubble.setButtons([]);
                game.robot.isBeingLed = false;
                game.robot.taskPlan = [];
                // console.log("game.tasks.robotActions[game.robot.currentActionI].robotAction.targetStr", game.tasks.robotActions[game.robot.currentActionI].robotAction.targetStr);
                // console.log("game.semanticLabelsToXY[game.tasks.robotActions[game.robot.currentActionI].robotAction.targetStr]", game.semanticLabelsToXY[game.tasks.robotActions[game.robot.currentActionI].robotAction.targetStr]);
                var goalLocs = game.semanticLabelsToXY[game.tasks.robotActions[game.robot.currentActionI].robotAction.targetStr];
                game.robot.goalTile = goalLocs[Math.floor(Math.random() * goalLocs.length)]
                game.robot.plan = generatePlan(game.robot.currentTile, [game.robot.goalTile], game.robot.goalTile, isValidTile);
                setRobotState(robotState.GO_TOWARDS_GOAL); // TODO (amal): might the user expect the robot to go into the target room, instead of just walking away?
                setRobotActionInProgress(false);
              },
            },
          ]);
        }
      }

      function setRobotState(state) {
        // if (!game.hasRobotStateChangedThisUpdate) {
        //   game.robot.previousState = game.robot.currentState;
        //   game.hasRobotStateChangedThisUpdate = true;
        // }
        game.robot.currentState = state;
      }

      function isOffCamera(tile) {
        var cameraBounds = getCameraBounds();
        return (tile.x < cameraBounds.left - cameraPadding ||
                tile.x >= cameraBounds.right + cameraPadding ||
                tile.y < cameraBounds.up - cameraPadding ||
                tile.y >= cameraBounds.down + cameraPadding);
      }

      function setRobotActionInProgress(val) {
        if (game.robot.actionInProgress && !val) {
          game.robot.currentActionI++;
        }
        game.robot.actionInProgress = val;
      }

      function initializeGamePlayerTimer(scene) {
        game.player.negativeScoreTimer = null;
        game.player.timer = scene.time.addEvent({
          delay: game.tasks.tasks[game.player.taskI].timeLimit*1000,
          loop: false,
          callback: function() {
            game.player.negativeScoreTimer = scene.time.addEvent({
              delay: 1000, // 1 sec
              loop: true,
              callback: function() {
                game.scoreText.setFill("#ff0000");
                game.player.score -= 1;
              },
            });
          },
        });
      }

      function update(time, delta) {

        if (load) {
          if (dataToLoad.length > 0) {
            var dtime = Date.now() - game.start_time;
            while (dataToLoad.length > 1) {

              console.log("dtime", dtime, "dataToLoad[0].dtime", dataToLoad[0].dtime);

              game.player.currentTile = dataToLoad[0].player.currentTile;
              game.player.nextTile = dataToLoad[0].player.nextTile;
              if (lastLoadedData == null || game.player.anims.getCurrentKey() != lastLoadedData.player_anim_key) game.player.anims.play(dataToLoad[0].player_anim_key, true);
              if (!dataToLoad[0].player_anim_is_playing) game.player.anims.stop();

              game.robot.currentTile = dataToLoad[0].robot.currentTile;
              game.robot.plan = dataToLoad[0].robot.plan;

              if (!dataToLoad[0].active_player_movement_timer) {
                game.player.movementTimer = null;
              } else if (lastLoadedData != null && dataToLoad[0].active_player_movement_timer && !lastLoadedData.active_player_movement_timer && game.player.movementTimer == null) {
                game.player.movementTimer = this.time.addEvent({delay: playerMsPerStep});
              }

              renderPlayerMovementAnimation();
              if (game.player.movementTimer == null) {
                if (hasCompletedCurrentTask()) {
                  game.player.taskI++;
                  regenerateInstructionText();
                }
                var gameXY = tileToGameXY(game.player.currentTile);
                game.player.x = gameXY.x;
                game.player.y = gameXY.y;
              }

              if (!dataToLoad[0].active_robot_movement_timer) {
                game.robot.movementTimer = null;
              } else if (lastLoadedData != null && dataToLoad[0].active_robot_movement_timer && !lastLoadedData.active_robot_movement_timer && game.robot.movementTimer == null) {
                game.robot.movementTimer = this.time.addEvent({delay: robotMsPerStep});
              }

              renderRobotMovementAnimation();
              if (game.robot.movementTimer == null) {
                var gameXY = tileToGameXY(game.robot.currentTile);
                game.robot.x = gameXY.x;
                game.robot.y = gameXY.y;
              }

              var next_dtime = dataToLoad[1].dtime;
              if (dtime >= next_dtime) {
                lastLoadedData = dataToLoad.splice(0, 1);
              } else {
                lastLoadedData = dataToLoad[0];
                break;
              }
            }

            if (dataToLoad.length == 1) {
              console.log("Finished Playback!");
              dataToLoad = []
            }
          }
        } else {

          regenerateInstructionText();
          regenerateScoreText();

          // If we are in the middle of rendering a player movement animation
          var hadMovementTimer = game.player.movementTimer != null;
          var completedMovement = false;
          renderPlayerMovementAnimation();
          completedMovement = hadMovementTimer && game.player.movementTimer == null;

          if (completedMovement) {
            game.player.elapsedDistanceSinceComputingTaskPlan++;
            game.robot.elapsedDistanceSinceComputingTaskPlan++;
            // Check if we have completed a task
            if (hasCompletedCurrentTask()) {
              game.player.taskI++;
              game.player.timer.destroy();
              if (game.player.taskI < game.tasks.tasks.length) {
                if (game.player.negativeScoreTimer != null) {
                  game.scoreText.setFill("#ffffff");
                  game.player.negativeScoreTimer.destroy();
                  game.player.negativeScoreTimer = null;
                }
                initializeGamePlayerTimer(this);
                getCurrentTaskPlan();
                game.player.currentTaskDistance = game.player.taskPlan.length;
              }
              game.player.score += 10;
              setRobotActionInProgress(false);
              if (game.robot.currentState != robotState.OFFSCREEN && game.robot.currentState != robotState.WALK_PAST_HUMAN) {
                setRobotState(robotState.WALK_PAST_HUMAN);
              }
            }

            if (game.player.taskPlan == null || game.player.taskPlan.length == 0 || game.player.elapsedDistanceSinceComputingTaskPlan >= Math.floor(game.player.taskPlan.length/5)) {
              getCurrentTaskPlan();
            }
            if (game.robot.isBeingLed) {
              if (game.robot.taskPlan == null || game.robot.taskPlan.length == 0 || game.robot.elapsedDistanceSinceComputingTaskPlan >= Math.floor(game.robot.taskPlan.length/5)) {
                getCurrentPlanToRobotGoal();
              }
            }

            if (!game.robot.actionInProgress && game.robot.currentState == robotState.OFFSCREEN) {
              if (game.robot.currentActionI < game.tasks.robotActions.length) {
                var robotAction = game.tasks.robotActions[game.robot.currentActionI];
                // Has the human completed the precondition task?
                if (game.player.taskI == robotAction.afterHumanTaskIndex + 1) {
                  var requiredDistanceToGoal = Math.ceil(game.player.currentTaskDistance*(1.0-robotAction.humanDistanceProportionToNextGoal));
                  var oldTaskPlanDistanceFromRequiredDistance = game.player.taskPlan.length - requiredDistanceToGoal;
                  if (game.player.elapsedDistanceSinceComputingTaskPlan >= Math.floor(oldTaskPlanDistanceFromRequiredDistance*0.5)) {
                    getCurrentTaskPlan();
                    var distanceProportionToNextGoal = 1.0 - game.player.taskPlan.length/game.player.currentTaskDistance;
                    console.log("distanceProportionToNextGoal", distanceProportionToNextGoal, robotAction.humanDistanceProportionToNextGoal);
                    // Has the human traversed enough distance to trigger the robot action?
                    if (distanceProportionToNextGoal >= robotAction.humanDistanceProportionToNextGoal) {
                      setRobotActionInProgress(true);

                      var robotSpawnTile = getOffScreenTileInDirectionOfHumanMotion(false);
                      console.log("robotSpawnTile", robotSpawnTile);
                      setRobotState(robotState.STATIONARY);

                      // Spawn the robot there
                      game.robot.currentTile = robotSpawnTile;
                      game.numTimesAskedForHelp = 0;

                      // Change the helpBubbleText
                      if (game.tasks.robotActions[game.robot.currentActionI].robotAction.query == "amIHere") {
                        setHelpBubbleToAmIHere();
                      } else if (game.tasks.robotActions[game.robot.currentActionI].robotAction.query == "leadMe") {
                        setHelpBubbleToLeadMe(false);
                      } /*else if (game.tasks.robotActions[game.robot.currentActionI].robotAction.query == "walkPast") {
                        game.robot.tileAtBeginningOfWalkPast = robotSpawnTile;
                      }*/
                    }
                  }
                }
              }
            }
          }

          // If we have finished rendering the last player movement animation
          if (game.player.movementTimer == null) {
            var newAction = false;
            var shouldLogData = false;
            if (game.cursors.left.isDown) {
              game.player.nextTile = {
                x : game.player.currentTile.x - 1,
                y : game.player.currentTile.y,
              };
              game.player.anims.play('left', true);
              newAction = isValidTile(game.player.nextTile, false, true);
              shouldLogData = true;
            } else if (game.cursors.right.isDown) {
              game.player.nextTile = {
                x : game.player.currentTile.x + 1,
                y : game.player.currentTile.y,
              };
              game.player.anims.play('right', true);
              newAction = isValidTile(game.player.nextTile, false, true);
              shouldLogData = true;
            } else if (game.cursors.up.isDown) {
              game.player.nextTile = {
                x : game.player.currentTile.x,
                y : game.player.currentTile.y - 1,
              };
              game.player.anims.play('up', true);
              newAction = isValidTile(game.player.nextTile, false, true);
              shouldLogData = true;
            } else if (game.cursors.down.isDown) {
              game.player.nextTile = {
                x : game.player.currentTile.x,
                y : game.player.currentTile.y + 1,
              };
              game.player.anims.play('down', true);
              newAction = isValidTile(game.player.nextTile, false, true);
              shouldLogData = true;
            } else {
              if (game.player.anims.isPlaying) shouldLogData = true;
              game.player.anims.stop();
            }

            if (newAction) {
              game.player.movementTimer = this.time.addEvent({delay: playerMsPerStep});
            }
            // Log the game state
            if (shouldLogData && !load) logData(logGameStateEndpoint, getGameState());
          }

          // If we are in the middle of rendering a robot movement animation
          renderRobotMovementAnimation();

          // If we have finished rendering the last robot movement animation
          if (game.robot.movementTimer == null) {
            if (game.robot.actionInProgress) {
              if (game.tasks.robotActions[game.robot.currentActionI].robotAction.query == "amIHere" ||
                  game.tasks.robotActions[game.robot.currentActionI].robotAction.query == "leadMe") {
                if (game.numTimesAskedForHelp >= numTimesToTryAskingForHelp) {
                  game.robot.helpBubble.setVisible(false);
                  setRobotState(robotState.WALK_PAST_HUMAN);
                  setRobotActionInProgress(false);
                } else {

                  if (!game.robot.isBeingLed) {
                    // If the human is far enough from you to try moving towards
                    // them again, do so
                    if (distance(game.robot.currentTile, game.player.currentTile) >= moveTowardsHumanDistance) {
                      game.robot.helpBubble.setVisible(false);
                      if (game.robot.currentState == robotState.STATIONARY) {
                        game.numTimesAskedForHelp += 1;
                      }
                      setRobotState(robotState.APPROACH_HUMAN);
                    }

                    // If the human is too far away from you to answer the query,
                    // make the query invisible.
                    // if (distance(game.robot.currentTile, game.player.currentTile) >= queryAnsweringDistance) {
                    //     game.robot.helpBubble.setVisible(false);
                    // }

                    // When you are close enough to the human, display the query
                    // and stop moving
                    if (distance(game.robot.currentTile, game.player.currentTile) <= queryAskingDistance) {
                      game.robot.helpBubble.setVisible(true);
                      setRobotState(robotState.STATIONARY);
                    }
                  }
                }
              } else if (game.tasks.robotActions[game.robot.currentActionI].robotAction.query == "walkPast") {
                if (game.robot.currentState == robotState.OFFSCREEN) {
                  setRobotActionInProgress(false);
                } else {
                  setRobotState(robotState.WALK_PAST_HUMAN);
                }
              }
            // Else if the robot is on screen but not doing a task
          } /*else if ((game.robot.currentTile.x != game.tasks.robot_offscreen_location.x || game.robot.currentTile.y != game.tasks.robot_offscreen_location.y)) {
              // Have the robot move off-screen
              if (game.robot.currentState != robotState.OFFSCREEN) {
                setRobotState(robotState.WALK_PAST_HUMAN);
              }
            }*/

            var robotStateToEvaluate = game.robot.currentState;
            switch(robotStateToEvaluate) {
              case robotState.OFFSCREEN:
                game.robot.tileAtBeginningOfWalkPast = null;
                game.robot.currentTile = {x : game.tasks.robot_offscreen_location.x, y : game.tasks.robot_offscreen_location.y};
                game.robot.goalTile = game.robot.currentTile;
                game.robot.plan = null;
                break;
              case robotState.APPROACH_HUMAN:
                game.robot.tileAtBeginningOfWalkPast = null;
                if (game.robot.plan == null || game.robot.plan.length == 0 || game.robot.goalTile == null || game.robot.goalTile.x != game.player.currentTile.x || game.robot.goalTile.y != game.player.currentTile.y) {
                  game.robot.goalTile = game.player.currentTile;
                  game.robot.plan = generatePlan(game.robot.currentTile, [game.robot.goalTile], game.robot.goalTile, isValidTile);
                }
                break;
              case robotState.WALK_PAST_HUMAN:
                console.log("game.robot.previousState", game.robot.previousState, "isOffCamera(game.robot.currentTile)", isOffCamera(game.robot.currentTile), "game.numTimesRobotOnScreen", game.numTimesRobotOnScreen);
                // If we just transitioned to WALK_PAST, set numTimesRobotOnScreen to 0
                if (game.robot.previousState != robotState.WALK_PAST_HUMAN) {
                  game.numTimesRobotOnScreen = 0;
                }
                if (isOffCamera(game.robot.currentTile) && game.numTimesRobotOnScreen > 0) {
                  game.robot.helpBubble.setVisible(false);
                  // game.hasRobotStateChangedThisUpdate = false;
                  setRobotState(robotState.OFFSCREEN);
                } else {

                  if (!isOffCamera(game.robot.currentTile)) {
                    game.numTimesRobotOnScreen++;
                  }

                  if (game.robot.tileAtBeginningOfWalkPast == null) {
                    game.robot.tileAtBeginningOfWalkPast = game.robot.currentTile;
                  }

                  if (game.robot.previousState != robotState.WALK_PAST_HUMAN || game.robot.plan == null || game.robot.plan.length == 0 || game.player.previousTaskI != game.player.taskI) {
                    // Have the robot move off-screen
                    var tile = getOffScreenTileInDirectionOfHumanMotion(true);
                    if (tile == null) {
                      tile = getOffScreenTile();
                      if (tile == null) {
                        game.robot.goalTile = game.robot.currentTile; // stop the robot
                      } else {
                        game.robot.goalTile = tile;
                      }
                    } else {
                      game.robot.goalTile = tile;
                    }
                    game.robot.plan = generatePlan(game.robot.currentTile, [game.robot.goalTile], game.robot.goalTile, isValidTile);
                  }
                }
                break;
              case robotState.STATIONARY:
                game.robot.tileAtBeginningOfWalkPast = null;
                game.robot.goalTile = game.robot.currentTile;
                game.robot.plan = null;
                break;
              case robotState.LEAVE_SCREEN:
                if (isOffCamera(game.robot.currentTile)) {
                  game.robot.helpBubble.setVisible(false);
                  // game.hasRobotStateChangedThisUpdate = false;
                  setRobotState(robotState.OFFSCREEN);
                } else {
                  // Have the robot move off-screen
                  if (game.robot.previousState != robotState.LEAVE_SCREEN || game.robot.plan == null || game.robot.plan.length == 0 || game.player.previousTaskI != game.player.taskI) {
                    var tile = getOffScreenTile();
                    if (tile == null) {
                      game.robot.goalTile = game.robot.currentTile; // stop the robot
                    } else {
                      game.robot.goalTile = tile;
                    }
                    game.robot.plan = generatePlan(game.robot.currentTile, [game.robot.goalTile], game.robot.goalTile, isValidTile);
                  }
                }
                break;
              case robotState.GO_TOWARDS_GOAL:
                if (isOffCamera(game.robot.currentTile)) {
                  game.robot.helpBubble.setVisible(false);
                  // game.hasRobotStateChangedThisUpdate = false;
                  setRobotState(robotState.OFFSCREEN);
                }
                break;
              default:
                break;
            }
            game.robot.previousState = robotStateToEvaluate;

          }

          // If we have finished rendering the last robot movement animation
          if (game.robot.movementTimer == null && game.robot.plan != null && game.robot.plan.length > 0) {
            // If the robot's plan would collide with the human
            if ((game.robot.plan[0].x == game.player.currentTile.x && game.robot.plan[0].y == game.player.currentTile.y) ||
                (game.robot.plan[0].x == game.player.nextTile.x && game.robot.plan[0].y == game.player.nextTile.y)) {
                // If the human is in the goal position, terminate the plan
                if (game.robot.plan.length == 1) {
                  game.robot.plan = null;
                }
                // Else, replan
                else {
                  game.robot.plan = generatePlan(game.robot.currentTile, [game.robot.goalTile], game.robot.goalTile, isValidTile);
                }

            }
            if (game.robot.plan != null) {
              game.robot.movementTimer = this.time.addEvent({delay: robotMsPerStep});
              // Log the game state
              if (!load) logData(logGameStateEndpoint, getGameState());
            }
          }
        }
        // if (!game.hasRobotStateChangedThisUpdate) {
        //   game.robot.previousState = game.robot.currentState;
        // }
        game.player.previousTaskI = game.player.taskI;
      }
    </script>

  </body>
</html>
